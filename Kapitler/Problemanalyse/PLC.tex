\section{\glsentrylong{plc}}
En \gls{plc} kan betegnes som en digital computer, designet til at håndtere multiple analog/digitale \gls{io}. \gls{plc}'en anvendes ofte til elektromekaniske anlæg, hvor de samme handlinger skal udføres sekventielt, med en lav fejlrate, og med en høj sekventiel udførselshastighed. \gls{plc}'en er et reeltids-system, hvoraf outputs' tilstande er et direkte resultat af indgangenes tilstand. I nedenstående afsnit vil \gls{plc}'ens hardware og software blive fremført, med det formål at kunne synliggøre \gls{plc}'ens fordele og ulemper. Ulemperne vil afslutningsvist blive opsummeret i problembeskrivelsen, som kan læses i kapitel \ref{sec:problembeskrivelse}. 

\subsection{Hardware}
\label{subsec:pa-hardware}
Den største hardwaremæssige forskel på en \gls{plc} og andre digitale computere, er at \gls{plc}'en har en konstruktion, som egner sig specifikt til belastende arbejdsmiljøer. \gls{plc}'en er dermed ekstrem modstandsdygtig overfor støv, temperatursvigninger og luftfugtighed \cite{PLC_hardware_desc}. 
Figur \ref{fig:omron-plc} viser en af Omrons mest populære \gls{plc}'er, \enquote*{SYSMAC CP1H}. \gls{plc}'en har 24 indgange og 17 udgange (markeret på figur \ref{fig:omron-plc}), hvor COM-porten på indgangsmodulet, giver mulighed for at bestemme den \textit{fælles logik}\fn{Fælles logik}{Spændingspotentiale mellem indgang og den tilhørende COM-port\cite{PLC_NPN_PNP}}. Hertil kan der tilsluttes DC 24V (positiv logik) eller DC 0V (negativ logik), afhængig af kundens præferencer. I Europa anvendes DC 0V som fælles logik, modsat i USA - hvor der anvendes DC 24V. 

For at en \gls{plc} kan køre, er der naturligvis nogle elementære betingelser som skal være opfyldt; \gls{plc}'en skal tilsluttes vekselspænding (230V) på indgangssiden, og ét fungerende program skal være indlæst. Yderligere informationer angående betingelser, anbefalinger og sikkerhedsmæssige krav, vil denne rapport ikke komme nærmere ind på. Der henvises for yderligere information til Omrons Instruktionsmanual \cite{basic_knowledge_plc}.

Omron CP1H understøtter flere programstadier, som indikeres ved at dioderne lyser (se figur \ref{fig:omron-plc}). Det er således muligt at tænde \gls{plc}'en uden at sætte den i \textit{run-mode}. Ydermere indikeres det, hvis der er opstået en fejl i \gls{plc}-koden, ved at \enquote*{ERR/ALM} lyser rød. 

\figur{Figurer/Billeder/plc-omron-hardware.jpg}{\gls{plc} Omron SYSMAC CP1H. Er i gruppens besiddelse.}{omron-plc}{0.8}

\noindent \gls{plc}'ers mekaniske konstruktion er meget varierende fra producent til producent, og fra model til model. Nogle producenter har adskillige modeller, som hver især er blevet konstrueret til et specifikt arbejdsmæssigt formål. Nogle modeller er således konstrueret med udvidelsesmoduler, hvor andre - mere simple \gls{plc}'er - er konstrueret med få indgange/udgange. 
Den store konstruktionsmæssige variation mellem \gls{plc}-fabrikanterne begrænser den enkelte virksomheds fleksibilitet. Der er således ikke mulighed for at sammenkoble et udvidelsesmodul af producenten, Omron, på en \gls{plc} produceret af Allen Bradly\cite{PLC-comb}. På figur \ref{fig:omron-plc} kan der ses en låge, som er markeret med EXP \enquote*{Udvidelsesmodul}, hvilket giver mulighed for at udvide \gls{plc}'en med flere I/O-moduler. 

I dag bliver de fleste automatiserede anlæg konstrueret med en \gls{plc}. Det giver den pågældende virksomhed mulighed for at konstruere et anlæg, hvor der skal færre tilpasninger til, før anlægget kan benyttes i flere forskellige arbejdsmiljøer. Det medvirker ligeledes til forøget fleksibilitet ved slutkunden, da reguleringer kan foretages hurtigt og uden større mekaniske indgreb.

\noindent For at give en bedre forståelse for \gls{plc}'en, vil nedenstående afsnit korfattet introducere tre \gls{plc}-producenter. Indledningsvist vil Siemens blive introduceret, som er en af de største \gls{plc}-producenter på markedet. Omron er på lige fod med Siemens et udbredt fabrikat, som benyttes i rigtig mange automatiserede anlæg. Omron's \gls{plc}-model, \enquote*{SYSMAC CP1H}, er samtidig tilgængelig for gruppen. CODESYS er de ledende udviklere af softwareapplikation til \gls{plc}'er, og har udviklet CODESYS SP6, som bygger på det \gls{oop} programmeringsparadigme.

\subsubsection*{PLC-producenter}
\label{subsec:siemens}
\noindent\textbf{Siemens} er klart de største på \gls{plc} markedet \cite{plc-marked-shares}. Igennem fire generationer af \gls{plc}'er, er Siemens én af de mest kompetente \gls{plc}-producenter på markedet - både på det hardware- såvel som det softwaremæssige plan. Den fjerde generation, \enquote*{Simatic S7} som er Siemens seneste udgave, bliver anvendt i mange aspekter af industrien. I året 2012, lancerede Siemens et nyt IDE, som stadig benytter sig af det logiske programmeringsparadigme. De har trods den massive softwaremæssige udvikling - hvoriblandt det \gls{oop} programmeringsparadigme er blevet populært (se afsnit \ref{subsec:codesys} og \ref{subsec:software_codesys}) - valgt at holde fast i det logiske paradigme. \\

\label{subsec:omron}
\noindent\textbf{Omron} blev etableret i 1972, og havde i starten fokus på små indlejede systemer til f.eks. lommeregnere. Nogle af disse komponenter blev blandt andet distribueret til Harvard University. Det var først fem år senere, da Omron påbegyndte deres \gls{plc}-standardlinje, kaldet \enquote*{SYSMAC PLC}, at \gls{plc}'er blev deres primære produktionsfokus. I dag opererer Omron i mere end 80 lande i Europa, Nordamerika samt i Asien\cite{plc-marked-shares}. Omron benytter sig ligeledes stadig af det logiske programmeringsparadigme.\\

\label{subsec:codesys}
\noindent\textbf{CODESYS} er udviklet af det Tyske softwarefirma, 3S-Smart Software Solutions, som i år 1994 var klar med første udgave af CODESYS. Det som gør CODESYS unik, er at de har implementeret et \gls{oop} programmeringssprog i version 3, som giver mulighed for polymorfisme, nedarvning og indkapsling. Det \gls{oop}-paradigme kan hjælpe den enkelte programmør, som har programmeringserfaring foruden industritekniker-uddannelsen, med at forøge abstraktionsniveauet. \gls{oop} giver mulighed for at benytte klasser, enkapsulering samt nedarvning til at strukturer programmet. \gls{oop} er dog i de fleste tilfælde et ineffektivt paradigme at programmere i. Størrelsen, antal operationer og kompleksiteten af disse opgaver, som skal udføres på det pågældende anlæg, afgøre ofte om hvorvidt det \gls{oop}-paradigmet er en fordel eller ej. Konkrete eksempler på hvordan CODESYS har implementeret \gls{oop} i deres \gls{ide} kan læses i afsnit \ref{subsec:software_codesys}. \\

\noindent \gls{plc}'ens hardware og de førende \gls{plc}-producenter er nu blevet gennemgået; hvor det blev belyst at \gls{plc} mekaniske konstruktion er modstanddygtige overfor barske arbejdsmiljøer. Ydermere blev der fremført, at de fleste \gls{plc}-producenter, som f.eks. Siemens og Omron, stadig benytter sig af det logiske programmeringsparadigme. Det næste afsnit vil komme nærmere ind på, hvad årsagerne er til, at producenterne ikke udvikler sig mere på det softwaremæssige område.

\subsection{Software}
%% PDF TIL PLC-GENNEMGANG: 
%% http://www.etf.unssa.rs.ba/~slubura/Procesni%20racunari/Programmable%20Logic%20Controllers%204th%20Edition%20%28W%20Bolton%29.pdf
Programmeringsprog til \gls{plc}'en har ikke udviklet sig meget siden indtoget i 1960'erne (se afsnit \ref{subsec:siemens} og \ref{subsec:omron}). Dette kan umildbart skyldes flere faktorer; Brugerne, herunder industrien og slutkunderne, efterspørger ikke et moderne programmeringssprog i en sådan grad, at producenter, såsom Siemens og Omron ønsker at efterkomme kravet. Det skyldes naturligvis at \gls{plc}-producenternes kunder, og deres ønsker, er en direkte funktion af \gls{plc}-producenternes udviklingsforetagende. \\

\noindent Industrien, som køber og programmere \gls{plc}'erne, besidder kun de mest basale programmeringsfaglig kundskaber. Mange af \gls{plc}-programmørene er uddannet industriteknikere, og har kun haft et grundlæggende \gls{plc}-kursus på 10 uger. Det betyder, at skal der foretages større og mere avancerede programmeringsopgaver bliver det enten købt ude, eller også bliver programmet kodet i en særskilt afdeling - adskilt fra selve montagearbejdet. Denne problemstilling er også noget, som berører den enkelte slutkunde, da de ofte har brug for selvstændigt at regulerer og fejlfinde på det købte anlæg.

Efteruddannelse til de ansatte kunne selvfølgelig afhjælpe dette problem, men det koster ressourcer og fleksibilitet i medarbejderstaben. Problemet falder dog hurtigt tilbage på slutkunden, som enten skal tilkøbe en serviceaftale, eller også er de ligeledes nødsaget til at efteruddanne deres egne medarbejdere. \\

\noindent En anden årsag kunne være, at de fleste produktionsvirksomheder ikke har brug for \gls{oop}'s kompleksitet og abstraktion, da de fleste anlæg er relativ simple opbygget, og kun foretager sig et par enkelte operationer (se afsnit \ref{subsec:codesys}). Det er naturligvis meget variende fra produktionsvirksomhed til produktionsvirksomhed. En typisk virksomhed indenfor produktionsanlæg til slagterier, opbygger ofte deres anlæg i moduler. Herved har de mulighed for at lave en specifik styring til dispensering af bakker, og et særskilt anlæg som behandler selve transporteringen af bakkerne. Det gør at størrelsen, og dermed også, at kompleksiteten holdes på et forholdsvist lavt niveau. \\

\noindent Det logiskbaserede programmeringsparadigme, som de fleste \gls{plc}-programmører stadig benytter, er primitivt og simpelt at gå til. Det er hurtigt at opsætte et fungerende program, og opsætte de enkelte \textit{rungs} og funktionsblokke som anlægget har brug for. Skriv- og læsbarheden er relativ høj, sålænge at programmet er simpelt. Ved større programmer bliver læsbarheden hurtigt forringet, og selv for avancerede \gls{plc}-programmører er det svært at holde programmet overskueligt. Et eksempel på dette kan ses på figur \ref{fig:siemens-lad}. \mfix{Man kan jo ikke se lortet...}

\subsubsection{Programmeringssprog til \gls{plc}'er}
\noindent I år 1993 blev det første udkast til \gls{iec} 1131-3 standarden publiceret\cite{iecStandard}. Standarden havde til formål at sikre en generalisering af hvordan software til \gls{plc}'er skrives og forstås. Igennem årene er det blevet mere og mere normalt, at både slutkunden, leverandøren og \gls{plc}-producenten følger, og efterspørger denne standard. 

\gls{iec} 1131-3 standarden definerer fem forskellige programmeringssprog til en \gls{plc}. To grafiske (\gls{lad} og \gls{fbd}) og tre tekstrepræsenterede (\gls{il}, \gls{sfc} og \gls{st}) sprog. Alle sprog kan kombineres på kryds og tværs af hinanden. Det er dermed muligt for den enkelte programmør at opstille programmet i \gls{lad}, ved at skrive det i \gls{il} og benytte sig af predefinerede funktionsblokke fra \gls{fbd}. Ønsker programmøren selv at definerer sine egne funktionblokke, som kan indeholde aritmetiske udtryk, kan \gls{st} anvendes. Dette betyder at programmøren i visse tilfælde er nødsaget til at have kendskab til - og skifte imellem flere programmeringssprog, for at få konstrueret den ønskede funktion. Hurtigt kan kompleksiteten af sproget stige, da der ikke kun er ét sprog der læres og forståes. Programmøren skal have en grundlæggende forståelse for alle fem sprogs syntaktiske opbygning og betydning. Det ville muligvis gøre det nemmere for programmøren, såfremt at de fem sprog blev samlet til ét sprog, med det forbehold, at udtrykskraften, skriv- og læsbarheden forbliver høj.

Fire af sprogenen vil nu blive gennemgået, for at afgøre hvilke fordele og ulemper sprogene hver især har, samt at belyse hvilke funktionaliteter de giver \gls{plc}'en.

\subsubsubsection{Ladder Diagrams}
\gls{lad} er et grafisk programmeringssprog, der har fået navnet fra dens grafiske repræsentation, som ligner en stige. \gls{lad} er det mest elementære sprog i \gls{plc}, hvilket vil sige, at de andre sprog, bygges op omkring \gls{lad}-diagrammet. Skal der tilføjes ekstra funktionalitet, som \gls{lad} ikke understøtter, anvendes de andre sprog. 

Funktionerne er opbygget i \textit{sekventielle trin}\fn{Sekventielle trin}{Ved initialisering udføres programmet henholdsvist fra top mod bund}, hvorved den almene PLC-programmeringskonsensus, er at navngive funktionerne: "Trin \textit{n: <Funktionsnavn>}". 
\gls{lad} opstilles i såkaldte \textit{rung}'s, og ved brug af logiske funktionsblokke, såsom \textit{AND}, \textit{OR}, \textit{NOT}, \textit{NAND}, \textit{NOR}, \textit{XOR}, kan der defineres regler for hvornår en given udgang skal tænde/slukke. 

I \gls{ide}'et kan man ved hjælp af Drag \& Drop-funktionalitet indsætte kontaktsæt, timere og andre funktionsblokke, som aktiveres når de opstillede betingelser er opfyldte. På figur \ref{fig:Ladder} ses et simpelt \gls{lad}-program. \textit{AND}, \textit{OR} og \textit{COIL}-symboler som repræsenterer en ind/udgang på \gls{plc}'en. Første linje viser, at udgangen Q10.00 aktiveres, såfremt indgangene \textit{( ( 000.01 \&\& 000.04) || 000.00 ) \&\& 000.02 )} er aktive.

\figur{Figurer/Billeder/Ladder.png}{Grafisk repræsentation af ladder programmering}{Ladder}{0.4}

\noindent \gls{lad} kan anvendes i et \textit{monitor}-program som giver programmøren mulighed for at se programmet i realtime. Hvorved det kan ses hvilke funktionsblokke der er aktive, værdier i hukommelsen, samt at \textit{enforce} (ON/OFF) kontaktsæt. Det er en stor hjælp, når eksempelvis der skal fejlfindes på anlægget. Igennem \enquote*{CX-programmer}, som er Omrons programmerings-\gls{ide}, er det dermed muligt at se præcis hvilke funktionsblokke der er aktive, betingelser (indgange og \textit{SET}-blokke) for udgange, samt hvilke værdier der er allokeret i \gls{plc}'ens hukommelse. 
\gls{lad} har grundet sin grafiske repræsentation en høj læsbarhed; sålænge at programmet holdes relativt lille og simpelt. Denne antagelse er bygget på egne erfaringer, og bliver ydermere underbygget af figur \ref{fig:siemens-lad}. Figuren viser et relativt simpelt anlæg som bestod af et transportbånd, en række sensorer og en drejearm. 

\figur{Figurer/Billeder/siemens_plc.jpg}{\gls{lad}-diagram konstrueret i Siemens Step7 (tilsvarende Omrons)}{siemens-lad}{1.0}

\noindent Udsnittet af programmet, som kan ses på figur \ref{fig:siemens-lad}, undersøger hvilken position drejearmen er i, og på baggrund af dette, afgøre hvilken retning drejearmen skal dreje. Programmet er en del af \textit{scan-cycle} og bliver dermed kørt i en uendelig løkke. De mange betingelser og \textit{coils} kan besværliggøre læsbarheden, hvorved tilpasninger i programmet kan blive en tidskrævende og besværlig proces.

Det blev tidligere nævnt, at aritmetiske udtryk skal programmeres i \gls{st}-funktionsblokke, som det næste afsnit vil komme nærmere ind på. 

\subsubsubsection{Structured Text}
\gls{st} er baseret på Pascal, og har den tilsvarende syntaktiske struktur. \gls{st} kan anvendes i kombination med \gls{lad}, hvorved det er er muligt at udtrykke aritmetiske operationer, iterative loops og funktioner. \gls{st} udtrykkes i en seperat funktionsblok, og benyttes ved at hente funktionsblokken ind i \gls{lad}-diagrammet. Det skal således aktiveres med en LD-blok (LOAD), som ikke er mulig at udtrykke i \gls{st}-sproget. Det er dermed ikke muligt at strukturer hele programmet i ét \gls{st}-program, hvilket heller ikke er hensigten. \gls{st} er hjælpefunktioner, som anvendes i tilfælde, hvor der skal foretages en bestemt opgave, som nemmere kan udtrykkes i en seperat funktionblok - og som ikke allerede er udtryk i én eksisterende funktionsblokke. Det kan dermed øge programmets læsbarhed, idet at det er muligt at kategorisere specifikke funktionaliteter i adskilte program-blokke. Disse funktionsblokke kan anvendes op til flere gange. 

Kodeeksempel \ref{code:st_exsample} viser et simpelt \gls{st}-program, som iterer med \textit{WHILE}, og multiplicerer 2 til variablen \textit{Var1}.

\ST{Kode/StructuredTextExsample.tex}{Eksempel for en simpel state machine}{st_exsample}

\noindent Et tilsvarende program kan konstrueres i \gls{il}-sproget, hvorom læsbarheden bliver meget forringet. Mere om dette kan læses i afsnit \ref{subsec:il-pa}. 

\subsubsubsection{Function Block Diagram}
\gls{fbd} er den anden grafiske programmeringsrepræsentation. I Omrons CX-Programmer er der en masse predefinerede funktionsblokke som kan anvendes, herunder TIM (Timer) og CNT (Counter) blokke. \gls{fbd} anvendes sammen med \gls{lad}, hvorved en LD-blok eventuelt kan aktivere Inputs (se figur \ref{fig:FBD}), og en COIL-blok (Udgang) kan aktiveres når funktionsblokkens betingelse er opfyldt. Ønsker programmøren at tilføje egen funktionalitet til programmet, eksempelvis ved at benytte det forrige \gls{st}-sprog, eller \gls{il}, er det muligt ved at definerer en funktionsblok. Et konkret eksempel kunne være, at programmøren ønsker at standaliserer sin kode, ved at definerer en funktionsblok som repræsentere én motor. Hertil skal motoren have \textit{n}-antal inputs for at starte, og et output som sender et signal til en frekvensomformer. Denne kommunikation bliver oftest repræsenteret i HEX - som er almen koderepræsentation på frekvensomformere. \fn{Frekvensomformer}{Anvendes til at regulere motorer; deres eksponentielle startid, spin-hastighed m.v.}. Et simpelt FBD-diagram kan ses på figur \ref{fig:FBD}.

\figur{Figurer/Billeder/FBD.jpg}{Grafisk repræsentation af et \gls{fbd}}{FBD}{0.4}

\noindent \gls{fbd} kan siges at fungere som et bibliotek, som kan importeres i projekter som skal have tilføjet den konkrete funktionalitet \cite{FDB_desc}.

\label{subsec:il-pa}
\subsubsubsection{Instruction List}
\gls{il} beskrives nemmest som et tekstrepræsenteret LAD-programmeringssprog. \gls{il} består af en række instruktioner; én instruks pr. linje. En instruks kan bestå af én eller flere operander. Ulempen ved \gls{il} er, at \gls{plc}-producenterne ikke vælger at følge konventionen (jf. \gls{iec} 1131-3), hvorved notationen skifter på tværs af producenterne. Kodeeksempel \ref{code:fixedfee-il} viser et relativt simpelt program som grundlæggende beregner et gebyr, og sætter en udgang på \gls{plc}'en. Denne operation bliver foretaget ved at benytte en predefineret \textit{LD}-instruks \enquote*{P\_First\_Cycle} (Omron standard), som kun køres én gang under programinitialisering. Dette bliver benyttet som \textit{init()}-metoden, på tilsvarende måde, som det kendes fra Arduino-programmeringssproget \cite{ardiono_code_init}. På linje 2 bliver der erklæret en \textit{stack}, hvorefter en global variabel med værdien 2, bliver flyttet til et defineret hukommelsesområde. Herefter bliver funktionerne erklæret og kaldt med \gls{il}-instrukserne: \enquote*{SBN} og \enquote*{SBS}. Afslutningsvist bliver udgangen Q\#100.00 sat med instruksen \enquote{OUT}. 

\IL{Kode/FixedFee-IL.tex}{Simpelt eksempel på IL-kode, som består af 2 metoder og 2 funktioner. Der bliver udregnet et gebyr, hvorefter en udgang sættes på \gls{plc}'en. Kodeeksemplet er direkte konverteret fra PLC++, og kan ses i bilag \ref{bil:fixedfee}}{fixedfee-il}

\noindent I kodeeksemplet \ref{code:fixedfee-il} kan programmet hurtigt blive uoverkommeligt - og det er på trods af, at programmet kun foretager et par operationer. Det er svært at adskille funktionerne fra hinanden, deres kroppe, samt at gennemskue funktionernes kaldstidspunkter. Skal anlægget fejlfindes under aktiv kørsel, er det ikke muligt for programmøren at se programmet eksekveringsstadier og værdier. Læsbarheden kan dermed erkendes som værende relativ lav i det tekstrepræsenteret \gls{il}. Imidlertid er det muligt at få \gls{il}-instrukserne konverteret til et \gls{lad}-diagram, hvilket også giver mulighed at køre programmet i realtime - hvorved hukommelsesområder kan inspectes, watches kan opsættes og eksekveringstadierne kan give en pegning om hvorhenne programmet fejler. Figur \ref{fig:fixedfee-graphic} viser forrige kodeeksempel \ref{code:fixedfee} i Omrons's IDE \enquote*{CX-Programmer}.

\figur{Figurer/Billeder/fixedfee.jpg}{Screendump af Omrons's IDE (Viser kodeeksempel \ref{code:fixedfee-il} i en grafisk repræsentation)}{fixedfee-graphic}{1} \mfix{Synes alt det udenom diagrammet skal fjernes}

\noindent Figur \ref{fig:fixedfee-graphic} viser nogle grønne streger, som indikerer hvilke \textit{rungs} og elementer i programmet, som er aktive. Ydermere kan det ses at \textit{P\_First\_Cycle} er blevet initialiseret, da værdien 2, er blevet flyttet til hukommelsesområdet W402 i \gls{plc}'en.

Der findes hundredevis af instrukser i \gls{il}, som gør \gls{il} til at funktionelt sprog, med mange muligheder. Omron har udarbejdet en \gls{il}-programmeringsmanuel, hvor alle instrukser, med tilhørende beskrivelse er blevet samlet. Programmeringsmanuellen kan ses læses her \cite{omron-il-manuel}. \\ 

\noindent Producenterne har valgt - som tidligere nævnt - at benytte deres egne notationer for \gls{il}-instrukser. Hertil kan det nævnes, at Omron benævner instruksen \textit{ST} som \textit{OUT}, hvor Siemens eksempelvis har valgt \textit{AN} som deres notation for \textit{ANDN}. Det betyder grundlæggende at der vil opstå kompatibilitetsproblemer mellem de enkelte producenter og de enkelte modeller, vedmindre der undersøges hvilken \gls{plc}-model den generede kode fra PLC++, skal eksekveres på \cite{FDB_desc}.

Fordelen ved \gls{il} er, at det er muligt at udtrykke hele \gls{plc}-programmet i \gls{il}, hvilket inkluderer aritmetiske udtryk, kontaktsæt og funktioner. 

\subsubsubsection{Objektorienteret Programmering}
\label{subsec:software_codesys}

CODESYS blev tidligere gennemgået (se afsnit \ref{subsec:codesys}), hvor det blev belyst at CODESYS har forsøgt at implementere \gls{oop}-programmeringsparadigmet i \gls{plc}-universet. Figur \ref{fig:plc-codesys-sample} viser CODESYS's IDE, hvor det både et muligt at kode i \gls{lad}-programmering, og samtidig få skrevet det tilhørende kode i \gls{oop}. Det giver dermed programmøren mulighed for at afgøre, om hvorvidt han ønsker at benytte \gls{oop} eller \gls{lad}. Vinduerne opdateres i realtime, hvorved det er muligt at se kodeeksempler, udfra den logik der bliver sammensat i \gls{lad}-vinduet. 

\figur{Figurer/Billeder/codesys_sample.png}{Screendump af CODESYS's IDE (Viser henholdsvist \gls{oop} og \gls{lad} i samme IDE)}{plc-codesys-sample}{1}

\noindent CODESYS beskriver deres \gls{oop}-implementation med følgende fordele\cite{codesys-oop-benefits}:
\begin{itemize}
\item Eksisterende programmer kan nemmere blive ændret, eller udbygget - samtidig med at de er nemmere at vedligeholde
\item Kodegenbrug er muligt, hvorved indkapsling er blevet forbedret radikalt
\item Performance er blevet forbedret, dog ikke for mindre programmer
\end{itemize}

\noindent\gls{oop}-programmeringsparadigmet kan - såfremt at programmøren besidder den nødvendige programmeringserfaring - medvirke til et velstruktureret program. Foruden CODESYS, er der også en række andre producenter, som har forsøgt at implementere \gls{oop} - her kan der bl.a. nævnes Beckhoff, som har en kraftig tilvækst igennem det sidste årti. I året 1999 omsatte Beckhoff for \$50 millioner, som i året 2010 er steget til \$346 millioner. Dette indikerer at flere vælger at migrere over til \gls{oop}, fremfor det traditionelle \gls{lad}, og \gls{oop} kan dermed anses for at være i et gunstigt indtog i det mangfoldige \gls{plc}-univers\cite{beckhoff-sold}.


%\gls{fbd} er den anden grafiske måde at repræsentere et \gls{plc}-program. \gls{fbd} er programmeret ved hjælp af de samme logiske blokke som omtalt i \gls{lad}. Ligeledes kan på samme måde bruge mere avancerede blokke som timere og tællere. På figur \ref{fig:FBD} ses et eksempel på Et simpelt Function Block Diagram.




%Figur \ref{fig:plc-il} viser et simpelt eksempel på et \gls{il}-repræsenteret program. \textit{LD} udtrykker operatoren, og instruerer at \textit{A} skal indlæses i \gls{mar}\fn{\gls{mar}}{Holder hukommelsesplaceringen af dét data som ønskes tilgået}. Det kan dermed blive kaldt af andre operationer. Den næste linje, har det boolske udtryk, \textit{ANDN}, som definerer at \textit{B} ikke skal registreres. \textit{ST} er et udtryk for at resultatet skal indlæses i \textit{C}. 



%\noindent \gls{lad} egner sig til simple programmer, hvor der kun anvendes binære variabler. Da eksekveringen af programmet sker trinvis sekventielt, kan der dermed opstå periodiske \textit{race conditions\fn{Race Condition}{Udtrykker at outputs er afhængig af en specifik hændelsesrækkefølge eller timing}}, som kan være meget besværlige at fejlfinde. Aritmetiske operationer og analoge input kan være besværlige at udtrykke; hvoraf notationen kan variere på tværs af producenterne. Ydermere er iterative kontrolstrukturer ikke understøttet i form af \textit{For}, \textit{While} eller \textit{Do While}-loops. \gls{lad}-programmering anvender istedet \textit{countere}-funktionsblokke, som kan konfigureres til at tælle én op ved hver iteration. Det er således ikke muligt at sende aktuelle parametre med til en funktion. Det kan i visse tilfælde medvirke til at programmøren er nødsaget til at implementere identiske funktioner, hvorved den eneste forskel er counterens \textit{preset}-værdi\fn{Preset-værdi}{Et udtryk for hvornår (counter-værdi) den aktuelle counter skal ændre status til høj}. \\






%\noindent Flere softwarefirmaer har forsøgt at implementere det objektorienterede paradigme i \gls{plc}'en. For mange industriteknikere, som også fungerer som \gls{plc}-programmører i industrien, kan \gls{oop} dog blive for omstændigt. For at kunne programmere et funktionelt program i det \gls{oop} paradigme, kræver den anderledes abstrakt tænkegang, som for mange; kan forekomme meget uoverskuelig i begyndelsen. Det kræver således, at den enkelte programmør, er villig til give slip på gamle vaner og notationer - hvilket kan være en tidskrævende proces.
%Mange \gls{plc}-programmører holder derfor fast i de gamle og velkendte programmeringsrutiner. Dette kan i visse tilfælde, som tidligere nævnt, ligeledes skyldes arbejdspladsens konservative indgangsvinkel\cite{PLC_Siemens_OOP}.  \\











%\subsubsection{Opsummering}

%% PROS
%\noindent Efter eksempler for hvordan en \gls{plc} kan programmeres ved hjælp af den tidligere omtalte \gls{iec}-standard. Fælles for dem alle, er at de benytter de samme komponenter. Det er en fordel, da man kan benytte forskellige sprog til samme program. Ligeledes kan den enkelte programmør vælge det sprog, de mener passer bedst til dem. \gls{lad} henvender sig specielt til elektrikere, da symbolikken ligner mekaniske kontaktorer og spoler. \gls{fbd} henvender sig til elektronikteknikere, da symbolikken minder meget om logiske AND og OR gates.

%%CONS
%Fælles for alle de omtalte sprog, er at de som tidligere nævnt, benytter sig af de samme objekter. Det sætter en række begrænsninger i hvordan man kan designe sin kodearkitektur. Ved store systemer opdeler man ofte programmet i forskellige abstraktioner. Ligeledes indkapsler man forskellige dele, for at øge læsbarheden samt bidrage til simpliciteten. Disse udfordringer er specielt gældende for overstående \gls{iec} standard, da sproget er designet fra et perspektiv om at forskellige typer programmører skal kunne skrive \gls{plc}-kode. Disse typer kunne eksempelvis være elektrikere, elektronikteknikere og computerprogrammører.


%\subsection{Siemens}
%Siemens er klart de største på PLC markedet, og med fire generationer af PLC´er har Siemens erfaring med produceringen af softwaren og hardware til PLC´en.

%Den fjerde generation Sematic 7 som er den nuværende, bliver brugt i mange aspekter i industrien, heriblandt specielt automatisering af handlinger på fabrikker.
%Dette kunne f.eks. være en slagter, som laver flere tons hakket kød. Her har man før i tiden, skulle have en medarbejder, til at finde ud af hvornår der skulle mere kød i maskinen, hvor man nu har en PLC til med tilhørende sensorer som styrer hvornår der kan komme mere kød i.
%Siemens benytter hertil 3 forskellige programmeringssprogs, hvor det ene er  Ladderprogramming som indeholder en editor, compiler samt en debugger. 
%Editoren gør det muligt at skrive eller ændre i filer herunder kan man også benytte blokke. blokke kan man betegne lidt som en slags modul, hvor man let kan indsætte flere funktioner med en enkelt blok eller flere blokke.
%Dernæst bruger man dets kompiler, som kompilere koden, sammen med blokkene som man har brugt.
%Dette bliver dernæst omdannet til maskinkode som dernæst bliver kørt igennem debuggeren.
%Debuggeren kigger maskinkoden igennem efter logiske fejl, som kunne være opstået. 
%Til får man en compileret udgave af programmet som er tjekket for logiske fejl, som dernæst kan overføres til PLC´en.

%Ideen med denne type af programmeringssprog, er at det skulle være let, for en ikke programmør at komme i gang med programmering, uden yderligere oplæring. Dermed er ideen om drag-and-drop kodning, ganske simpel for en medarbejder at komme i gang med.

% \subsubsection{Interface for Ladderprogrammering}
% Interfacet til Ladderprogrammering på Siemens PLC´er, er meget simpelt og er opbygget som vist på Figur \ref{fig:SiemensLadder}.

% \figur{Figurer/SiemensLadder.png}{Siemens programmerings interfacel}{SiemensLadder}{1}

% \noindent Programmet har en menu i venstre side, hvor programmøren kan vælge kodeblocke og indsætte direkte i koden som et modul.
% Programmøren har ligeledes mulighed for finde instruktioner som f.eks. hvordan man inverter en værdi, eller simpelt bit logik, i venstre side af programmet.
% I højre side af programmet har man sit hovedvindue, hvor alt det grafiske bliver repræsenteret.

% \subsection{Omron}
% Omron har eksisteret siden 1972, hvor Omron begyndte at producere små enheder til f.eks. lommeregnere. Nogle af disse komponenter som blandt andet blev leveret til Harvard University, blev betegnet for at være en form for PLC, dog blev den aldrig masseproduceret, og blev derfor kun specielt produceret.
% Det var først i 1977 hvor Omron producerede deres standardlinje af PLC´er kaldet SYSMAC PLC, som blev masseproduceret. Her blev Omrons tidligere erfaringer med små enheder - microcontrollere samlet til at konstruere en PLC, som var starten på Omrons PLC marked.
% Næsten 10 år efter producerede Omron C200H PLC, som bliver brugt endnu den dag, i dag. Dog havde Omron svært ved at sælge den, mest af alt pga. at Siemens havde 4 år forinden lanceret deres Simatic S5, som var banebrydende på det givende tidspunkt.
% I dag har omron ca. 40 procent af markede på PLCér i Japan og operere i mere end 80 lande, herunder i Europa, Nord America, Kina og Asien.
% \mefix{indsæt http://www.omron.com/about/corporate/business/domain/iab/index.html}

% \subsection{CODESYS}
% CODESYS er udviklet af det Tyske softwarefirma 3S-Smart Software Solutions som i 1994 var klar med første udgave af CODESYS V 1.0 hvilket var tiden hvor automatisering af handlinger virkelig begynde at blive udnyttet.

% I modsætning til flere af CODESYS’ konkurrenter valgte de at udgive deres produkt med en gratis licens. Dette gjorde at de blev meget attraktive på marked, da man ikke længere skulle investere store midler i licenser, når man kunne få det gratis med produktet.
% Det som gør CODESYS’en speciel er at de har implementeret et objektorienteret  programmeringssprog i version 3, som gør at man lettere kan adskille forskellige arbejdsopgaver, og dermed muligheden for at outsource dele af programmet.
% Den objektorienteret tilgang introducere metoder, interfaces, klasser og polymorfi samt try/catch.

% Dette er dog først blevet implementeret i CODESYS V3, hvor der førhen ikke har været den objektorienteret tilgang, hvilket gjorde det usikkert i forhold til exception handling.
% Exception handlingen har gjort det væsentligt mere sikkert, i forhold til at medarbejderen som planlægger hvad PLC´en skal gøre, har mulighed for at tage sikkerhedsforanstaltninger med hensyn til hvad maskinen skal gøre hvis den oplever en fejl.
% Ved at forudse og behandle eventuelle fejl, kan man på den måde altid få maskinen til at lukke helt ned, med en finally-block i try/catch.