\section{\glsentrylong{plc}}
\label{sec:plc-pa}
En \gls{plc} kan betegnes som en digital computer, designet til at håndtere flere analog/digitale \gls{io}. \gls{plc}'en anvendes ofte til styringsanlæg, hvor de samme handlinger skal udføres sekventielt, med en lav fejlrate, og med en høj sekventiel udførselshastighed. \gls{plc}'en er et system, hvor outputs' tilstande er et direkte resultat af indgangenes tilstand. I nedenstående afsnit vil \gls{plc}'ens hardware og software blive fremført, med det formål at kunne synliggøre \gls{plc}'ens fordele og ulemper. Ulemperne vil afslutningsvist blive opsummeret i problembeskrivelsen, som kan læses i kapitel \ref{sec:problembeskrivelse}. 

\subsection{Hardware}
\label{subsec:pa-hardware}
Den største hardwaremæssige forskel på en \gls{plc} og andre digitale computere, er at \gls{plc}'en har en konstruktion, som egner sig specifikt til belastende arbejdsmiljøer \cite{PLC_hardware_desc}.
Figur \ref{fig:omron-plc} viser en af Omrons mest populære \gls{plc}'er, \enquote*{SYSMAC CP1H}. \gls{plc}'en har 24 indgange og 17 udgange (markeret på figur \ref{fig:omron-plc}), hvor COM-porten på indgangsmodulet, giver mulighed for at bestemme den fælles logik\fn{Fælles logik}{Spændingspotentiale mellem indgang og den tilhørende COM-port\cite{PLC_NPN_PNP}}. Hertil kan der tilsluttes DC 24V (positiv logik) eller DC 0V (negativ logik), afhængig af kundens præferencer. 

Før en \gls{plc} kan køre, er der naturligvis nogle elementære betingelser som skal være opfyldt; \gls{plc}'en skal tilsluttes vekselspænding (230V) på indgangssiden, og et fungerende program skal være indlæst. Yderligere informationer angående betingelser, anbefalinger og sikkerhedsmæssige krav, vil denne rapport ikke komme nærmere ind på. Der henvises for yderligere information til Omrons Instruktionsmanual \cite{basic_knowledge_plc}.

Omron CP1H understøtter flere programstadier, som indikeres ved at dioderne lyser (se figur \ref{fig:omron-plc}). Det er således muligt at tænde \gls{plc}'en uden at sætte den i \textit{run-mode}. Ydermere indikeres det, hvis der er opstået en fejl i \gls{plc}-koden, ved at \enquote*{ERR/ALM} lyser rød. 

\figur{Figurer/Billeder/plc-omron-hardware.jpg}{\gls{plc} Omron SYSMAC CP1H. Er i gruppens besiddelse}{omron-plc}{0.8}

\noindent \gls{plc}'ers mekaniske konstruktion er meget varierende fra producent til producent, og fra model til model. Nogle producenter har adskillige modeller, som hver især er blevet konstrueret til et specifikt arbejdsmæssigt formål. Nogle modeller er således konstrueret med udvidelsesmoduler, hvor andre - mere simple \gls{plc}'er - er konstrueret med få indgange/udgange. 
Den store konstruktionsmæssige variation mellem \gls{plc}-fabrikanterne begrænser den enkelte virksomheds fleksibilitet. Der er således ikke mulighed for at sammenkoble et udvidelsesmodul af producenten, Omron, på en \gls{plc} produceret af Allen Bradly\cite{PLC-comb}. På figur \ref{fig:omron-plc} kan der ses en låge, som er markeret med EXP\fn{EXP}{Anvendes til udvidelsesmoduler}, hvilket giver mulighed for at udvide \gls{plc}'en med flere I/O-moduler.\\

\noindent I dag bliver de fleste automatiserede anlæg konstrueret med en \gls{plc}. Det giver den pågældende virksomhed mulighed for at konstruere et anlæg, hvor der skal færre tilpasninger til, før anlægget kan benyttes i flere forskellige arbejdsmiljøer. Det medvirker ligeledes til forøget fleksibilitet ved slutkunden, da reguleringer kan foretages hurtigt og uden større mekaniske indgreb.

\subsubsection{PLC-producenter}
\label{sec:plc}
\noindent For at give en bedre forståelse for \gls{plc}'en, vil nedenstående afsnit introducere tre \gls{plc}-producenter. Indledningsvist vil Siemens, som er en af de største \gls{plc}-producenter på markedet, blive introduceret. Omron er på lige fod med Siemens et udbredt fabrikat, som benyttes i rigtig mange automatiserede anlæg. Omron's \gls{plc}-model, \enquote*{SYSMAC CP1H}, er samtidig tilgængelig for gruppen. CODESYS er de ledende udviklere af softwareapplikation til \gls{plc}'er, og har udviklet CODESYS SP6, som bygger på det \gls{oop}

\label{subsec:siemens}
\subsubsubsection{Siemens}
\noindent En af de største \gls{plc}-producenter på markedet er Siemens \cite{plc-marked-shares}. Igennem fire generationer af \gls{plc}'er, er Siemens én af de mest kompetente \gls{plc}-producenter på markedet - både på det hardware- såvel som det softwaremæssige plan. Den fjerde generation, \enquote*{Simatic S7} som er Siemens' seneste udgave, bliver anvendt i mange aspekter af industrien. I år 2012 lancerede Siemens et nyt IDE, som stadig benytter sig af det logiske programmeringsparadigme. De har trods den massive softwaremæssige udvikling - hvoriblandt det \gls{oop} programmeringsparadigme er blevet populært (se afsnit \ref{subsec:codesys} og \ref{subsec:software_codesys}) - valgt at holde fast i det logiske paradigme. \\

\label{subsec:omron}
\subsubsubsection{Omron}
\noindent Omron blev etableret i 1972, og havde i starten fokus på små indlejede systemer til f.eks. lommeregnere. Nogle af disse komponenter blev blandt andet distribueret til Harvard University. Det var først fem år senere, da Omron påbegyndte deres \gls{plc}-standardlinje, kaldet \enquote*{SYSMAC PLC}, at \gls{plc}'er blev deres primære produktionsfokus. I dag opererer Omron i mere end 80 lande i Europa, Nordamerika samt i Asien\cite{plc-marked-shares}. Omron benytter sig ligeledes stadig af det logiske programmeringsparadigme.\\

\label{subsec:codesys}
\subsubsubsection{CODESYS}
\noindent CODESYS er udviklet af det tyske softwarefirma, 3S-Smart Software Solutions, som i år 1994 var klar med første udgave af CODESYS. Det som gør CODESYS unik, er at de har implementeret et \gls{oop} programmeringssprog i version 3, som giver mulighed for polymorfisme, nedarvning og indkapsling. Det \gls{oop}-paradigme kan hjælpe den enkelte programmør, som har programmeringserfaring foruden industritekniker-uddannelsen, med at forøge abstraktionsniveauet. \gls{oop} giver mulighed for at benytte klasser, indkapsling samt nedarvning til at strukturere programmet. \gls{oop} er dog i de fleste tilfælde et ineffektivt paradigme at programmere i. Størrelsen, antal operationer og kompleksiteten af disse opgaver, som skal udføres på det pågældende anlæg, afgør ofte om hvorvidt det objektorienterede paradigme er en fordel eller ej. Konkrete eksempler på hvordan CODESYS har implementeret \gls{oop} i deres \gls{ide} kan ses i afsnit \ref{subsec:software_codesys}. \\

\noindent \gls{plc}'ens hardware, og flere førende \gls{plc}-producenter, er nu blevet gennemgået, hvor det blev belyst at \gls{plc}'ens mekaniske konstruktion er modstanddygtige overfor barske arbejdsmiljøer. Ydermere blev der afdækket, at de fleste \gls{plc}-producenter, som f.eks. Siemens og Omron, stadig benytter sig af det logiske programmeringsparadigme. Det næste afsnit vil komme nærmere ind på, hvad årsagerne er til at producenterne ikke udvikler sig mere på det softwaremæssige område.

\subsection{Software}
\label{subsec:plcsoftware}
%% PDF TIL PLC-GENNEMGANG: 
%% http://www.etf.unssa.rs.ba/~slubura/Procesni%20racunari/Programmable%20Logic%20Controllers%204th%20Edition%20%28W%20Bolton%29.pdf
Programmeringsprog til \gls{plc}'en har ikke udviklet sig meget siden indtoget i 1960'erne (se afsnit \ref{subsec:siemens}). Dette kan umiddelbart skyldes flere faktorer; Brugerne, herunder industrien og slutkunderne, efterspørger ikke et moderne programmeringssprog i en sådan grad, at producenter, såsom Siemens og Omron ønsker at efterkomme kravet. Det skyldes naturligvis at \gls{plc}-producenternes kunder, og deres ønsker, er en direkte funktion af \gls{plc}-producenternes udviklingsforetagende. \\

\noindent Industrien, som køber og programmerer \gls{plc}'erne, besidder kun de mest basale programmeringsfaglig kundskaber. Mange af \gls{plc}-programmørene er uddannet industriteknikere, og har kun haft et grundlæggende \gls{plc}-kursus på 10 uger. Det betyder, at skal der foretages større og mere avancerede programmeringsopgaver bliver det enten outsourcet, eller også bliver programmet kodet i en særskilt afdeling - adskilt fra selve montagearbejdet. Denne problemstilling er også noget, som berører den enkelte slutkunde, da de ofte har brug for selvstændigt at regulere og fejlfinde på det købte anlæg.

\noindent Efteruddannelse til de ansatte kunne selvfølgelig afhjælpe dette problem, men det koster ressourcer og fleksibilitet i medarbejderstaben. Problemet falder dog tilbage på slutkunden, som enten skal tilkøbe en serviceaftale, eller efteruddanne deres egne medarbejdere. \\

\noindent En anden årsag kunne være, at de fleste produktionsvirksomheder ikke har brug for \gls{oop}'s kompleksitet og abstraktion. Det skyldes at de fleste anlæg er relativ simple opbygget, og kun foretager et par enkelte operationer. Det er naturligvis meget variende fra produktionsvirksomhed til produktionsvirksomhed. En typisk virksomhed, som sælger og producerer produktionsanlæg til slagterier, opbygger ofte deres anlæg i mindre moduler. Et konkret eksempel på dette, kunne være en bakkedispenserings-anlæg, med et tilhørende transportbånd. I dette tilfælde bliver anlægget ofte opdelt i moduler, hvorved ét anlæg håndterer selve operationen: bakkedispensering, og et andet anlæg håndtere selve transporteringen af bakkerne. Det medvirker til et mindre program - og dermed også - forøget simplicitet, da hvert anlæg er udstyret med sin egen \gls{plc}-strying. \\

\noindent Det logiskbaserede programmeringsparadigme, som de fleste \gls{plc}-programmører benytter (se afsnit \ref{subsec:siemens}), er primitivt og simpelt at gå til. Det er hurtigt at opsætte et fungerende program, og opsætte de enkelte rungs\fn{Rung}{Engelsk udtryk for trin. Benyttes til at strukture \gls{plc}-programmet i seperate Trin.} og funktionsblokke, som anlægget har brug for. Skriv- og læsbarheden er relativ høj, såfremt at programmet forbliver småt og simpelt. Ved større programmer bliver læsbarheden hurtigt forringet, og selv for avancerede \gls{plc}-programmører er det svært at holde programmet overskueligt. Et konkret eksempel på dette, vil blive gennemgået i afsnit \ref{subsec:lad}, og kan ses på figur \ref{fig:siemens-lad}. 

\subsubsection{Programmeringssprog til \gls{plc}'er}
\noindent I år 1993 blev det første udkast til \gls{iec} 1131-3 standarden publiceret \cite{iecStandard}. Standarden havde til formål at sikre en generalisering af hvordan software til \gls{plc}'er skrives og forstås. Igennem årene er det blevet mere og mere normalt, at både slutkunden, leverandøren og \gls{plc}-producenten følger og efterspørger denne standard. 

\noindent \gls{iec} 1131-3 standarden definerer fem forskellige programmeringssprog til en \gls{plc}. 
To grafiske (\gls{lad} og \gls{fbd}) og tre tekstrepræsenterede (\gls{il}, \gls{sfc} og \gls{st}) sprog. \\
\noindent Alle sprog kan kombineres på kryds og tværs af hinanden. Det er dermed muligt for den enkelte programmør at opstille programmet i \gls{lad}, ved at skrive det i \gls{il} og benytte sig af predefinerede funktionsblokke fra \gls{fbd}. Ønsker programmøren selv at definere egne funktionblokke, som blandt andet kan indeholde aritmetiske udtryk, kan \gls{st} anvendes. Dette betyder at programmøren - i visse tilfælde - skal have en grundlæggende forståelse for alle programmeringssprog, for at kunne konstruere den ønskede funktion. Sværhedsgraden og kompleksiteten i \gls{plc}-sproget kan hurtigt stige, da der ikke kun er ét sprog der skal læres og forståes. Det ville muligvis gøre det nemmere for programmøren, såfremt at de fem sprog blev samlet til ét sprog, med det forbehold, at udtrykskraften samt skriv- og læsbarheden forbliver høj - også ved mellemstore projekter.

\noindent Fire af sprogene vil nu blive gennemgået, for at afdække sprogenes funktionalitet samt deres fordele og ulemper. 

\subsubsubsection{Ladder Diagrams, LAD}\label{subsec:lad}
\gls{lad} er et grafisk programmeringssprog, der har fået navnet fra dens grafiske repræsentation, som ligner en stige. \gls{lad} kan anses for at være den grafiske repræsentation af \gls{il}, som vil blive gennemgået senere i dette afsnit. \gls{lad} og \gls{il} er selve fundamentet for at \gls{plc}'en kan eksekvere koden. Flere detaljer om dette vil blive gennemgået senere i afsnittet.\\

\noindent Funktionerne er opbygget i \textit{sekventielle trin}\fn{Sekventielle trin}{Ved initialisering udføres programmet henholdsvist fra top mod bund}, hvorved den almene PLC-programmerings-konsensus, er at navngive funktionerne: "Trin \textit{n: <Funktionsnavn>}".  
\gls{lad} opstilles i såkaldte \textit{rungs}, og ved brug af logiske blokke, såsom \textit{AND}, \textit{OR}, \textit{NOT}, \textit{NAND}, \textit{NOR}, \textit{XOR}, kan der defineres regler for hvornår en given udgang skal tænde/slukke. Se figur \ref{fig:Ladder}, hvor et simpelt \gls{lad}-diagram er blevet opstillet med to rungs.\\

\noindent I Omrons \gls{ide} er det muligt, ved hjælp af Drag \& Drop-funktionalitet, at indsætte \textit{LD}-instrukser\fn{LD}{Fungerer som en simpel kontakt, som er normally-open. Bliver repræsenteret med en bit i hukommelsen, hvor 1 = True, 0 = False.}, timere, countere og andre funktionsblokke, som aktiveres når de opstillede betingelser er opfyldte. På figur \ref{fig:Ladder} ses et simpelt \gls{lad}-program, hvor der er indsat logiske \textit{AND}-, \textit{OR}- og to \textit{COIL}-instrukser som repræsenterer udgangene på \gls{plc}'en. Første linje viser, at udgangen Q10.00 aktiveres, såfremt indgangene \textit{( ( 000.01 \&\& 000.04) || 000.00 ) \&\& 000.02 )} er aktive.

\figur{Figurer/Billeder/lad-simple-exsample.jpg}{Grafisk repræsentation af ladder programmering}{Ladder}{0.4}

\noindent \gls{lad} kan anvendes i et \textit{monitor}-program som giver programmøren mulighed for at se programmet, og dets eksekvering, i realtime. Dette giver mulighed for at se hvilke funktionsblokke der er aktive, allokerede værdier i hukommelsen, samt at ændre tilstanden på LD-instrukser. Det er en stor hjælp, når der eksempelvis skal fejlfindes på anlægget.  
\gls{lad} har grundet sin grafiske repræsentation en høj læsbarhed - såfremt programmet holdes relativt småt og simpelt. Denne antagelse er bygget på egne erfaringer, og bliver ydermere underbygget af figur \ref{fig:siemens-lad}. Figuren viser et relativt simpelt anlæg som bestod af et transportbånd, en række sensorer og en drejearm. 

\figur{Figurer/Billeder/siemens_plc.jpg}{\gls{lad}-diagram konstrueret i Siemens Step7 (tilsvarende Omrons)}{siemens-lad}{1.0}

\noindent Udsnittet af programmet, som kan ses på figur \ref{fig:siemens-lad}, undersøger positionen af drejearmen, og på baggrund af dette, afgører hvilken retning drejearmen skal rotere. Programmet er en del af \textit{scan-cycle}\fn{Scan-Cycle}{Kontinuerligt loop, som \gls{plc}'en altid befinder sig i. Mere om scan-cycle findes i \cite{scancycle-desc}.} og bliver dermed kørt i en uendelig løkke. De mange betingelser og \textit{coils} kan besværliggøre læsbarheden, hvorved tilpasninger i programmet kan blive en tidskrævende og uoverskueligt proces.

\noindent Det blev tidligere nævnt, at aritmetiske udtryk skal programmeres i \gls{st}-funktionsblokke, som det næste afsnit vil komme nærmere ind på. 

\subsubsubsection{Structured Text, ST}
\gls{st} er baseret på Pascal, og har den tilsvarende syntaktiske struktur. \gls{st} kan anvendes i kombination med \gls{lad}, hvorved det er er muligt at udtrykke aritmetiske operationer, iterative loops og funktioner. \gls{st} udtrykkes i en seperat funktionsblok, og benyttes ved at hente funktionsblokken ind i \gls{lad}-diagrammet. Det skal således aktiveres med en LD-instruks, som ikke er mulig at udtrykke i \gls{st}-sproget. Det er dermed ikke muligt at strukture hele programmet i ét \gls{st}-program, hvilket heller ikke er hensigten. \gls{st} er hjælpefunktioner, som anvendes i tilfælde, hvor der skal foretages en bestemt opgave - eller en matematisk udregning, som ikke allerede er udtryk i én af eksisterende funktionsblokke. Det kan dermed øge programmets læsbarhed, idet at det er muligt at kategorisere programmets funktionaliteter i adskilte funktionsblokke. Disse funktionsblokke kan anvendes op til flere gange, og kan gemmes seperat, således at de kan genanvendes i andre projekter.\\

\noindent Kodeeksempel \ref{code:st_exsample} viser et simpelt \gls{st}-program, som består af en \textit{WHILE}-løkke, hvor variablen \textit{Var1} bliver ganget med 2. Som det også kan ses i kodeeksemplet, er syntaksen meget lignende Pascal.

\ST{Kode/StructuredTextExsample.tex}{Simpelt eksempel på ST-kode}{st_exsample}

\noindent Et tilsvarende program kan konstrueres i \gls{il}-sproget, hvorom læsbarheden er meget forringet.  

\subsubsubsection{Function Block Diagram, FBD}
\gls{fbd} er den anden grafiske repræsentation. I Omrons programmerings-\gls{ide}, CX-Programmer, er der hundredevis af predefinerede funktionsblokke som kan anvendes - herunder TIM (Timer) og CNT (Counter) blokke. Ønsker programmøren at tilføje egen funktionalitet til programmet, eksempelvis ved at benytte det førnævnte \gls{st} eller \gls{il}, er det muligt ved at definere en funktionsblok. Et konkret eksempel kunne være, at programmøren ønsker at standardisere sin kode, ved at definere en funktionsblok, som repræsenterer en motor. Hertil skal motoren have \textit{n}-antal inputs for at starte, og et output som sender et signal til en frekvensomformer\fn{Frekvensomformer}{Anvendes til at regulere motorer; deres eksponentielle startid, spin-hastighed m.v.}. Denne kommunikation bliver oftest repræsenteret i HEX - som er almen koderepræsentation for frekvensomformere. Et simpelt FBD-diagram kan ses på figur \ref{fig:FBD}.

\figur{Figurer/Billeder/FBD.jpg}{Grafisk repræsentation af et \gls{fbd}}{FBD}{0.4}

\noindent \gls{fbd} kan siges at fungere som et bibliotek, som kan importeres i projekter som skal have tilføjet den konkrete funktionalitet \cite{FDB_desc}.

\subsubsubsection{Instruction List, IL}
\label{subsec:il-pa}
\gls{il} beskrives nemmest som et tekstrepræsenteret LAD-programmeringssprog. \gls{il} består af en række instruktioner; én instruks pr. linje. En instruks kan bestå af én eller flere operander. Ulempen ved \gls{il} er at \gls{plc}-producenterne ikke vælger at følge konventionen (jf. \gls{iec} 1131-3), hvorved notationen skifter på tværs af producenterne. Kodeeksempel \ref{code:fixedfee-il} viser et relativt simpelt program som grundlæggende beregner et gebyr og aktiverer en udgang på \gls{plc}'en. Denne operation bliver foretaget ved at benytte en predefineret LD-instruks \textit{P\_First\_Cycle} (Omron standard), som kun køres én gang under programinitialisering. Dette bliver benyttet som \textit{init()}-metoden, på tilsvarende måde, som det kendes fra Arduino-programmeringssproget \cite{ardiono_code_init}. På linje 2 bliver en \textit{stack} defineret, ved brug af \textit{SSET(630)}, hvorefter en global variabel med værdien 2, bliver flyttet til et hukommelsesområdet W402. Herefter bliver funktionerne defineret og kaldt med \gls{il}-instrukserne: \textit{SBN} og \textit{SBS}. Afslutningsvist bliver udgangen Q\#100.00 sat med instruksen \textit{OUT}. 

\IL{Kode/FixedFee-IL.tex}{Simpelt eksempel på IL-kode, som består af 2 metoder og 2 funktioner. Der bliver udregnet et gebyr, hvorefter en udgang sættes på \gls{plc}'en. Kodeeksemplet er direkte compileret fra PLC++, og kan ses i bilag \ref{bil:fixedfee}.}{fixedfee-il}

\noindent Som det også kan ses i kodeeksemplet \ref{code:fixedfee-il}, kan programmet hurtigt blive uoverkommeligt - og det er på trods af, at programmet kun foretager et par simple operationer. Det er svært at adskille funktionerne fra hinanden, deres tilhørende kroppe, samt at gennemskue funktionernes kaldtidspunkter. Skal anlægget fejlfindes under aktiv kørsel, er det ikke muligt for programmøren at se programmet eksekveringsstadier og værdier. Læsbarheden kan dermed erkendes som værende relativ lav i det tekstrepræsenteret \gls{il}. Imidlertid er det muligt - som tidligere nævnt - at få \gls{il}-instrukserne direkte konverteret til et \gls{lad}-diagram. Herved er det muligt at se programmet i realtime; hukommelsesområder kan inspectes, watches kan opsættes og eksekveringstadierne kan give en pegning om hvorhenne programmet fejler. Endvidere kan programmet ses i \gls{lad}-diagram, som har en meget højere læsbarhed. Figur \ref{fig:fixedfee-graphic} viser kodeeksempel \ref{code:fixedfee-il} i CX-Programmer.

\figur{Figurer/Billeder/fixedfee.jpg}{Screendump af Omrons's IDE (Viser kodeeksempel \ref{code:fixedfee-il} i en grafisk repræsentation)}{fixedfee-graphic}{1}

\noindent Figur \ref{fig:fixedfee-graphic} viser en LD-instruks, \textit{P\_First\_Cycle} i rung 0, som også var den første instruks i forrige kodeeksempel \ref{code:fixedfee-il}. CX-Programmer finder selv ud af, hvordan programmet skal oversættes og opsættes i rungs, mellem \gls{il} og \gls{lad}. Det betinger naturligvis at \gls{il}-instrukserne er brugt korrekt. 
Til fejlfinding lyser de grønne streger op, som indikerer hvilke instrukser og elementer i programmet, der er aktive. Ydermere kan det ses at \textit{P\_First\_Cycle} er blevet initialiseret (kun kørt én gang), da værdien 2, er blevet flyttet til hukommelsesområdet W402 i \gls{plc}'en.

\noindent Der findes hundredevis af instrukser i \gls{il}, som gør \gls{il} til et funktionelt sprog med mange muligheder. Omron har udarbejdet en \gls{il}-programmeringsmanuel, hvor alle instrukser, med tilhørende beskrivelse er blevet samlet. Programmeringsmanuellen kan findes i \cite{omron-il-manuel}. \\ 

\noindent Producenterne har valgt - som tidligere nævnt - at benytte deres egne notationer for \gls{il}-instrukser. Hertil kan det nævnes, at Omron anvender instruksen \textit{ST} som \textit{OUT}, hvor Siemens eksempelvis har valgt \textit{AN} som deres notation for \textit{ANDN}. Det betyder grundlæggende at der vil opstå kompatibilitetsproblemer mellem de enkelte producenter og de enkelte modeller, medmindre der undersøges hvilken \gls{plc}-model den generede kode skal eksekveres på \cite{FDB_desc}.

\noindent Fordelen ved \gls{il} er, at det er muligt at udtrykke hele \gls{plc}-programmet i \gls{il}, hvilket inkluderer aritmetiske udtryk, instrukser og funktionsblokkke. \\

\noindent Fire af \gls{plc}-sprogene i det logiskbaserede programmeringsparadigme er nu blevet afdækket. Kapitel \ref{sec:problembeskrivelse} vil opsummere på problemstillingerne, fordelene og ulemperne. Afslutningsvist vil CODESYS's implementation af \gls{oop}-paradigmet blive afdækket.

\label{subsec:software_codesys}
\subsubsection{Objektorienteret Programmering, OOP }
\noindent CODESYS blev kort gennemgået i se afsnit \ref{subsec:codesys}, hvor der blev redegjort for, at CODESYS har forsøgt at implementere \gls{oop}-programmeringsparadigmet i \gls{plc}'en. Figur \ref{fig:plc-codesys-sample} viser CODESYS's \gls{ide}, hvor det både er muligt at kode i \gls{lad}-programmering, og samtidig få skrevet det tilhørende kode i \gls{oop}. Det giver dermed programmøren mulighed for at afgøre, om hvorvidt han ønsker at benytte \gls{oop} eller \gls{lad}. Vinduerne opdateres i realtime, hvorved det er muligt at se kodeeksempler, udfra den logik der bliver sammensat i \gls{lad}-vinduet. 

\figur{Figurer/Billeder/codesys_sample.png}{Screendump af CODESYS's IDE (Viser henholdsvist \gls{oop} og \gls{lad} i samme IDE)}{plc-codesys-sample}{1}

\noindent CODESYS beskriver deres \gls{oop}-implementation med følgende fordele\cite{codesys-oop-benefits}:
\begin{itemize}
\item Eksisterende programmer kan nemmere blive ændret, eller udbygget - samtidig med at de er nemmere at vedligeholde
\item Kodegenbrug er muligt, hvorved indkapsling er blevet forbedret radikalt
\item Performance er blevet forbedret, dog ikke for mindre programmer
\end{itemize}

\noindent\gls{oop}-programmeringsparadigmet kan - såfremt programmøren besidder den nødvendige programmeringserfaring - medvirke til et velstruktureret program. Foruden CODESYS, er der også en række andre producenter, som har forsøgt at implementere \gls{oop} - her kan der bl.a. nævnes Beckhoff, som har en kraftig tilvækst igennem det sidste årti. I året 1999 omsatte Beckhoff for \$50 millioner, som i året 2010 er steget til \$346 millioner. Dette indikerer at flere vælger at migrere over til \gls{oop}, fremfor det traditionelle \gls{lad}, og \gls{oop} kan dermed anses for at være i et gunstigt indtog i det mangfoldige \gls{plc}-univers\cite{beckhoff-sold}. \\

\noindent Selvom der findes mange muligheder til selve \gls{plc}-programmeringen; \gls{lad}, \gls{st}, \gls{fbd}, \gls{il} og \gls{oop}, er der dog også en række hardware- og softwaremæssige begrænsninger. Det næste afsnit vil komme nærmere ind på disse begrænsninger.

\subsection{PLC begrænsninger}\label{sec:plcprob}
Der blev tidligere redegjort for (se afsnit \ref{subsec:pa-hardware}), at \gls{plc}'er primært anvendes til industrimaskiner, hvor hardwarens robusthed er en central faktor. Det er imidlertid lige så vigtigt at \gls{plc}'ens instruktioner eksekveres hurtigt og uden fejl. Dette skyldes at \gls{plc}'en gerne skal respondere hurtigt – eksempelvis ved at sætte en udgang på \gls{plc}'en, når en indgang bliver sat. 
Omron CP1H, som kan udføre 10.000 kIPS er væsentligt langsommere (faktor 118) end eksempelvis Raspberry Pi, som kan klare 1.183.799 kIPS \cite{raspBench}. En anden ulempe er antallet af operationer, hvor Omrons PLC CP1H har en begrænsning på 20.000 steps - hver instruktion kan være mellem 1 og 7 steps. Derudover har CP1H også en begrænsning på max 256 funktioner og max 256 jump  \cite{cp1h}. Dette giver nogle begrænsninger i forhold til udviklingen af et højniveau sprog. Eksempler på strukturer, som kræver jumps er selektive- og iterative kontrolstrukturer. Af disse årsager skal PLC++ implementeres med så få jumps som muligt i forhold til det genererede kode. Funktionaliteter som exception-handling bliver også udelukket, da dette ville kræve et ekstra tjek - eksempelvis ved alle divisioner. Omron sætter et \textit{error flag} ved division af 0 og ved fejl findes den nærmeste exception handler. \cite{exceptionHandling}\\

% Slet ikke dette!
% µ = 10^-6
% i/s = IPS = Instructions / second
% s/i = SPI = Seconds / instruction
% 1.000.000 /µ = 1

% Rasp 2
% 1.186 MIPS (Rasp PI) = 1.186.000 kIPS = 1.186.000.000 IPS

% 1.186.000.000 IPS = 1.000.000 /µ / x SPI
% 1.186.000.000 IPS * x SPI = 1.000.000 /µ
% x SPI = 1.000.000 /µ / 1.186.000.000 IPS
% 0,000843 µSPI = 1.000.000 /µ / 1.186.000.000 IPS

%CP1H 0.1 µs pr. LD instruction
% 0,1 µSPI = 1.000.000 /µ / x IPS
% 0,1 µSPI * x IPS = 1.000.000 /µ
% x IPS = 1.000.000 / µ * 0,1 µSPI
% 10.000.000 IPS = 1.000.000 / µ * 0.1 µSPI
% 10.000 kIPS

\noindent \gls{oop}-programmering er derudover også problematisk i forhold til polymorfisme. Ved polymorfisme skal der være en \gls{vmt} til alle metoder, der kan overskrives, hvilket vil give problemer ved brug af multiple kontrolstrukturer og nedarvende klasser. Polymorfisme vurderes derfor 
til at bidrage til flere ulemper end fordele, set i forhold til \gls{plc}-programmering. Nedarvning giver af selvsamme årsager ikke mening, da alle nedarvninger uden polymorfisme kan udtrykkes ved en simpel \textit{struct} der har en deklaration til den anden \textit{struct}. \cite{Sebesta_2013}\\ 

\noindent Eksekveringshastigheden vil i de fleste tilfælde stige proportionalt med abstraktionsniveauet. Der kan dog være visse tilfælde, hvor sproget er konstrueret, så det er muligt at lave avancerede optimeringer, ved at skrive det samme kode (i target sproget) på færre linjer.
Et eksempel på eksekveringshastigheden mellem det imperative- og det objektorienterede paradigme kan ses på performance-målinger mellem C og C++. I teorien skulle C++ være lige så hurtigt som C for ækvivalent kildekode (da næsten alle gyldige C programmer også er gyldige C++ programmer). I praksis er C++ kode normalt en lille smule langsommere end ækvivalente C programmer. Specielt under implementationen af det objektorienterede paradigme, sænkes hastigheden kontra en implementationen i C, der dog typisk vil blive langsommere. Så for alle hastighedskritiske systemer, er det objektorienterede paradigme mindre egnet kontra det imperative paradigme. \cite{codeprojectCPP} \cite{stackoverflowWhyCPP} \cite{linusWhyC} \cite{cVsCPPJOE}\\

\noindent Begrænsningerne belyst i dette afsnit vidner også om at projekterne udviklet til PLC'er typisk ikke er meget store projekter. Dog kan et nyt sprog stadig retfærdiggøres i forhold til de ulemper der er i forhold til \gls{lad} og \gls{il} ( belyst i afsnit \ref{subsec:lad}). Derudover belyses andre fordele i kapitel \ref{ch:losning}.

%http://www.codeproject.com/Questions/445035/C-vs-Cplusplus-performance
%https://stackoverflow.com/questions/497786/why-would-anybody-use-c-over-c
%http://thread.gmane.org/gmane.comp.version-control.git/57643/focus=57918
%http://unthought.net/c++/c_vs_c++.html









%\subsection{PLC begrænsninger}\label{sec:plcprob}\sfix{Problembeskrivelse skal have hastigheden med}
%Da PLC'er typisk er bygget til industrimaskiner og i et miljø hvor hardware robustheden er meget vigtig, er hastigheden på PLC'erne typisk meget langsom i forhold til en almindelig computer. Derudover er der typisk en maksimal størrelse på programmerne.

%Et eksempel er Omrons PLC CP1H. CP1H har en begrænsning på 20.000 steps, hvor hver instruktion kan være mellem 1 og 7 steps. Derudover har CP1H også en begrænsning på maks 256 subrutiner og maks 256 jump. \cite{cp1h}

%Dette giver nogle begrænsninger i forhold til udviklingen af et høj niveau sprog. Eksempler på strukturer der kræver jumps er selektive og iterative kontrolstrukturer. Derfor skal PLC++ have så få jumps som muligt ud fra det generede kode. Dermed bliver ting såsom exception handling også udelukket da dette kræver et ekstra tjek eksempelvis ved alle divisioner, da Omron sætter et error flag ved division af 0 og ved en fejl lave finde ud af hvor den nærmeste exception handler er.\cite{exceptionHandling}\\

%\noindent Objektorienteret programmering er derudover også problematisk i forhold til polyformeri. Ved polyformeri skal der være en virtual method table (vtable) til alle metoder der kan overskrives og dermed vil dette give problemer ved selv små programmer med multiple kontrolstrukturer og  klasser der nedarves. Polyformeri vurderes derfor til at være for problematisk at implementere for en PLC til at dette kan betale sig. Nedarvning giver derfor heller ikke mening, da alle nedarvninger uden polyformeri kan beskrives ved en simpel struct der har en deklaration til den anden struct. \cite{Sebesta_2013}\\ 

%\noindent Hastigheden vil næsten altid blive langsommere med højere abstraktionslag inkluderet sproget. Dog kan der være tilfælde hvor sproget er konstrueret således at det er muligt at lave avancerede optimeringer, så det er muligt at skrive det samme kode (i target sproget) med færre linjer. Et eksempel på dette er spørgsmålet om C er hurtigere end C++. I teorien skulle C++ være lige så hurtig som C, for ækvivalent kildekode (da næsten alle gyldige C programmer også er gyldige C++ programmer). I praksis er C++ kode normalt en lille smule langsommere end ækvivalente C programmer. Specielt under implementeringen af det objektorienterede paradigme sænkes hastigheden kontra en implementationen i C der dog typisk vil blive længere. Så for alle hastighedskritiske systemer er det objektorienterede paradigme mindre egnet kontra det imperative paradigme. \cite{codeprojectCPP} \cite{stackoverflowWhyCPP} \cite{linusWhyC} \cite{cVsCPPJOE}\\

%http://www.codeproject.com/Questions/445035/C-vs-Cplusplus-performance
%https://stackoverflow.com/questions/497786/why-would-anybody-use-c-over-c
%http://thread.gmane.org/gmane.comp.version-control.git/57643/focus=57918
%http://unthought.net/c++/c_vs_c++.html

%\noindent Begrænsningerne belyst i dette her afsnit vidner også om at projekterne udviklet til PLC'er typisk ikke er særligt store projekter. Dog kan et nyt sprog stadig retfærdiggøres i forhold til de ulemper der er i forhold til \gls{lad} og \gls{il} belyst i afsnit \ref{subsec:lad} og \ref{subsec:il-pa} og der vil desuden blive belyst andre fordele i kapitel \ref{ch:losning}.

% https://www.ia.omron.com/products/family/1778/specification.html

%Der er blevet valgt at fokusere på det imperative paradigme og derfor implementeres ikke nedarvning og polyformeri. Nedarvning og polyformeri bruger ofte flere ressourcer og er derfor uegnet til PLC verdenen da hastigheden kan have stor indflydelse. Derudover bliver \gls{plc} projekter oftest ikke så store, dels pga. de typiske opgavers kompleksitet og dels hastigheden på PLC'en. Implementeringen af det objektorinterede paradigme kan derfor ved større projekter som OOP er mest egnet til vise sig at blive for ressourcekrævende.\sfix{Skal vi flytte denne her del til problemanalyse og referere der til i stedet?}\sfix{Kilde på PLC er langsomt}


%\gls{fbd} er den anden grafiske måde at repræsentere et \gls{plc}-program. \gls{fbd} er programmeret ved hjælp af de samme logiske blokke som omtalt i \gls{lad}. Ligeledes kan på samme måde bruge mere avancerede blokke som timere og tællere. På figur \ref{fig:FBD} ses et eksempel på Et simpelt Function Block Diagram.

%Figur \ref{fig:plc-il} viser et simpelt eksempel på et \gls{il}-repræsenteret program. \textit{LD} udtrykker operatoren, og instruerer at \textit{A} skal indlæses i \gls{mar}\fn{\gls{mar}}{Holder hukommelsesplaceringen af dét data som ønskes tilgået}. Det kan dermed blive kaldt af andre operationer. Den næste linje, har det boolske udtryk, \textit{ANDN}, som definerer at \textit{B} ikke skal registreres. \textit{ST} er et udtryk for at resultatet skal indlæses i \textit{C}. 

%\noindent \gls{lad} egner sig til simple programmer, hvor der kun anvendes binære variabler. Da eksekveringen af programmet sker trinvis sekventielt, kan der dermed opstå periodiske \textit{race conditions\fn{Race Condition}{Udtrykker at outputs er afhængig af en specifik hændelsesrækkefølge eller timing}}, som kan være meget besværlige at fejlfinde. Aritmetiske operationer og analoge input kan være besværlige at udtrykke; hvoraf notationen kan variere på tværs af producenterne. Ydermere er iterative kontrolstrukturer ikke understøttet i form af \textit{For}, \textit{While} eller \textit{Do While}-loops. \gls{lad}-programmering anvender istedet \textit{countere}-funktionsblokke, som kan konfigureres til at tælle én op ved hver iteration. Det er således ikke muligt at sende aktuelle parametre med til en funktion. Det kan i visse tilfælde medvirke til at programmøren er nødsaget til at implementere identiske funktioner, hvorved den eneste forskel er counterens \textit{preset}-værdi\fn{Preset-værdi}{Et udtryk for hvornår (counter-værdi) den aktuelle counter skal ændre status til høj}. \\

%\noindent Flere softwarefirmaer har forsøgt at implementere det objektorienterede paradigme i \gls{plc}'en. For mange industriteknikere, som også fungerer som \gls{plc}-programmører i industrien, kan \gls{oop} dog blive for omstændigt. For at kunne programmere et funktionelt program i det \gls{oop} paradigme, kræver den anderledes abstrakt tænkegang, som for mange; kan forekomme meget uoverskuelig i begyndelsen. Det kræver således, at den enkelte programmør, er villig til give slip på gamle vaner og notationer - hvilket kan være en tidskrævende proces.
%Mange \gls{plc}-programmører holder derfor fast i de gamle og velkendte programmeringsrutiner. Dette kan i visse tilfælde, som tidligere nævnt, ligeledes skyldes arbejdspladsens konservative indgangsvinkel\cite{PLC_Siemens_OOP}.  \\

%\subsubsection{Opsummering}

%% PROS
%\noindent Efter eksempler for hvordan en \gls{plc} kan programmeres ved hjælp af den tidligere omtalte \gls{iec}-standard. Fælles for dem alle, er at de benytter de samme komponenter. Det er en fordel, da man kan benytte forskellige sprog til samme program. Ligeledes kan den enkelte programmør vælge det sprog, de mener passer bedst til dem. \gls{lad} henvender sig specielt til elektrikere, da symbolikken ligner mekaniske kontaktorer og spoler. \gls{fbd} henvender sig til elektronikteknikere, da symbolikken minder meget om logiske AND og OR gates.

%%CONS
%Fælles for alle de omtalte sprog, er at de som tidligere nævnt, benytter sig af de samme objekter. Det sætter en række begrænsninger i hvordan man kan designe sin kodearkitektur. Ved store systemer opdeler man ofte programmet i forskellige abstraktioner. Ligeledes indkapsler man forskellige dele, for at øge læsbarheden samt bidrage til simpliciteten. Disse udfordringer er specielt gældende for overstående \gls{iec} standard, da sproget er designet fra et perspektiv om at forskellige typer programmører skal kunne skrive \gls{plc}-kode. Disse typer kunne eksempelvis være elektrikere, elektronikteknikere og computerprogrammører.


%\subsection{Siemens}
%Siemens er klart de største på PLC markedet, og med fire generationer af PLC´er har Siemens erfaring med produceringen af softwaren og hardware til PLC´en.

%Den fjerde generation Sematic 7 som er den nuværende, bliver brugt i mange aspekter i industrien, heriblandt specielt automatisering af handlinger på fabrikker.
%Dette kunne f.eks. være en slagter, som laver flere tons hakket kød. Her har man før i tiden, skulle have en medarbejder, til at finde ud af hvornår der skulle mere kød i maskinen, hvor man nu har en PLC til med tilhørende sensorer som styrer hvornår der kan komme mere kød i.
%Siemens benytter hertil 3 forskellige programmeringssprogs, hvor det ene er  Ladderprogramming som indeholder en editor, compiler samt en debugger. 
%Editoren gør det muligt at skrive eller ændre i filer herunder kan man også benytte blokke. blokke kan man betegne lidt som en slags modul, hvor man let kan indsætte flere funktioner med en enkelt blok eller flere blokke.
%Dernæst bruger man dets kompiler, som kompilere koden, sammen med blokkene som man har brugt.
%Dette bliver dernæst omdannet til maskinkode som dernæst bliver kørt igennem debuggeren.
%Debuggeren kigger maskinkoden igennem efter logiske fejl, som kunne være opstået. 
%Til får man en compileret udgave af programmet som er tjekket for logiske fejl, som dernæst kan overføres til PLC´en.

%Ideen med denne type af programmeringssprog, er at det skulle være let, for en ikke programmør at komme i gang med programmering, uden yderligere oplæring. Dermed er ideen om drag-and-drop kodning, ganske simpel for en medarbejder at komme i gang med.

% \subsubsection{Interface for Ladderprogrammering}
% Interfacet til Ladderprogrammering på Siemens PLC´er, er meget simpelt og er opbygget som vist på Figur \ref{fig:SiemensLadder}.

% \figur{Figurer/SiemensLadder.png}{Siemens programmerings interfacel}{SiemensLadder}{1}

% \noindent Programmet har en menu i venstre side, hvor programmøren kan vælge kodeblocke og indsætte direkte i koden som et modul.
% Programmøren har ligeledes mulighed for finde instruktioner som f.eks. hvordan man inverter en værdi, eller simpelt bit logik, i venstre side af programmet.
% I højre side af programmet har man sit hovedvindue, hvor alt det grafiske bliver repræsenteret.

% \subsection{Omron}
% Omron har eksisteret siden 1972, hvor Omron begyndte at producere små enheder til f.eks. lommeregnere. Nogle af disse komponenter som blandt andet blev leveret til Harvard University, blev betegnet for at være en form for PLC, dog blev den aldrig masseproduceret, og blev derfor kun specielt produceret.
% Det var først i 1977 hvor Omron producerede deres standardlinje af PLC´er kaldet SYSMAC PLC, som blev masseproduceret. Her blev Omrons tidligere erfaringer med små enheder - microcontrollere samlet til at konstruere en PLC, som var starten på Omrons PLC marked.
% Næsten 10 år efter producerede Omron C200H PLC, som bliver brugt endnu den dag, i dag. Dog havde Omron svært ved at sælge den, mest af alt pga. at Siemens havde 4 år forinden lanceret deres Simatic S5, som var banebrydende på det givende tidspunkt.
% I dag har omron ca. 40 procent af markede på PLCér i Japan og operere i mere end 80 lande, herunder i Europa, Nord America, Kina og Asien.
% \mefix{indsæt http://www.omron.com/about/corporate/business/domain/iab/index.html}

% \subsection{CODESYS}
% CODESYS er udviklet af det Tyske softwarefirma 3S-Smart Software Solutions som i 1994 var klar med første udgave af CODESYS V 1.0 hvilket var tiden hvor automatisering af handlinger virkelig begynde at blive udnyttet.

% I modsætning til flere af CODESYS' konkurrenter valgte de at udgive deres produkt med en gratis licens. Dette gjorde at de blev meget attraktive på marked, da man ikke længere skulle investere store midler i licenser, når man kunne få det gratis med produktet.
% Det som gør CODESYS'en speciel er at de har implementeret et objektorienteret  programmeringssprog i version 3, som gør at man lettere kan adskille forskellige arbejdsopgaver, og dermed muligheden for at outsource dele af programmet.
% Den objektorienteret tilgang introducere metoder, interfaces, klasser og polymorfi samt try/catch.

% Dette er dog først blevet implementeret i CODESYS V3, hvor der førhen ikke har været den objektorienteret tilgang, hvilket gjorde det usikkert i forhold til exception handling.
% Exception handlingen har gjort det væsentligt mere sikkert, i forhold til at medarbejderen som planlægger hvad PLC´en skal gøre, har mulighed for at tage sikkerhedsforanstaltninger med hensyn til hvad maskinen skal gøre hvis den oplever en fejl.
% Ved at forudse og behandle eventuelle fejl, kan man på den måde altid få maskinen til at lukke helt ned, med en finally-block i try/catch.