\chapter{Konklusion}
\label{sec:konklusion}

Efter at have fuldendt problemløsningen kan der konkluderes i hvilken grad problemformuleringen er løst. Problemformuleringen har lagt til grund for kravspecifikationen, som indeholder de udspecificerede funktionaliteter. Disse funktionaliteter er, ved hjælp af en \gls{moscow}-analyse, blevet tildelt en prioritet, så funktionerne kan klassificeres ud fra dens vigtighed i den samlede løsning.



Kriteriet writeability blev vurderet til at være meget vigtig. Den primære motivation for et nyt sprog lå i effektiviteten i plc programmeringen havde en lav writeability. Ved implementering af det imperative sprog og dets komponenter som while loops 




Den samlede løsning vurderes ud fra hvilken grad kriterierne er opfyldt, hvilket belyses i afsnit \ref{subsec:il-pa}, hvor der påvises hvordan et eksempel i \gls{il} hurtig giver overblik, hvorimod \gls{lad} giver en mere indviklet oversigt. Bruger man det samme eksempel, og sammenligner \gls{il} med PLC++ (se bilag \ref{bil:fixedfee}, kan man se at koden er væsentlig mindre i PLC++.\\


\noindent Herudover kan programmøren let få et overblik med sine egne funktionsnavne, hvorimod man i \gls{il} har en SBN og SBS blok, som giver en reference i form af et id til den blok, den henviser til.
Derfor menes det at PLC++ giver et bedre overblik, samt en højere læsbarhed i form af at man ikke behøver at forholde sig til adressering af hukommelsesadresser.
Dertil kunne det tænkes at programmøren har lettere ved at lære PLC++ fremfor \gls{il}, da det har en højere  læsbarhed samt at programmøren ikke skal lære instruktioner, hvilket derfor leder til en bedre indlæringskurve. 

Dette er en bred påstand, som ikke umiddelbart kan underbygges med evidens udover konkret at se på kompleksiteten mellem \gls{il} og PLC++.
Det er dog langt fra alle industriteknikere som programmerer i \gls{il}. Mest af alt på grund af dets kompleksitet, som vist i kodeeksempel \ref{code:fixedfee-il}.
Derimod kodes der i \gls{lad}, som førhen er blevet konkluderet som værende et sprog med dårligt overblik for programmøren.
Når der konkluderes på \gls{lad}-programmering mod PLC++, er det vigtigt at man ser på hvilken målgruppe, der arbejdes med.
Dette har tidligere været defineret som værende til industriteknikere, med jævn programmeringserfaring.
Hvis man derudover kigger på mellemstore programmer, gør det sig gældende at \gls{lad}-programmering bliver meget uoverskueligt, og generelt er svær at rette i, hvorimod PLC++ giver et bedre overblik.\\

\noindent Rettes blikket derimod mod små programmer, har \gls{lad}-programmering en klar fordel, da programmøren ikke behøver at definere standardfunktioner, som \textit{Run} og \textit{Init}, som det er nødvendigt i PLC++. Derimod er det let for programmøren at få et overblik med drag-and-drop systemet, som grafisk giver et indblik i hvad der sker når koden eksekveres.

Dette vurderes som værende acceptabelt i forhold til at målet er specificeret til at være til mellemstore programmer.
Ved helt store programmer kunne det tænkes at det objektorienterede paradigme ville være mere praktisk, i forhold til at man kan benytte nedarvning samt polymorfisme. Dette er en påstand som ikke er testet, da dette ikke er en del af den endelige løsning samt at problemformuleringen er defineret anderledes.\\

\noindent Det må derfor erkendes, at problemformuleringen er delvist løst.
Dette skyldes delvist at der ikke er testet på hvorvidt problemformuleringen er opfyldt i forhold til de opstillede krav i \gls{moscow}-analysen.
Dertil er der foretaget afgrænsning af kriterierne fra \gls{moscow}-analysen, da det blev vurderet at arbejdsbyrden var for stor, i forhold til den mængde tid som var til rådighed i løbet af projektet.
Afgrænsningen vurderes til at være fundamental, for at opnå et projekt som lever op til studieordningen, og samtidig er brugbart.
For at kunne klassificere problemformuleringen som værende løst, ville det kræve at der bliver implementeret resterende funktioner fra \gls{moscow}-analysen, samt at der bliver udført test omkring hvorvidt programmeringssproget lever op til de opstillede krav.