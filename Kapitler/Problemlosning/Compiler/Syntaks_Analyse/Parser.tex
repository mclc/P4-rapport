\subsubsection{Parser}
Parserens opgave er at få opbygget et abstrakt syntakstræ ud fra de tokens som scanneren har fundet frem til. Det er dermed også parserens opgave at tjekket at reglerne i forhold til rækkefølgen af keywords, identifiers osv. er overholdt. En sådan regel kunne være hvordan man udtrykker et assignment. For at forstå hvordan parseren fungerer er der først et kort afsnit omkring abstrakte syntakstræer.

\subsubsubsection{Abstrakt syntakstræ}
Et abstrakt syntakstræ også forkortet AST er en træstruktur der er en repræsentation at kildekoden. Noderne i træet er forskellige dele af sproget såsom iterative kontrolstrukturer, eller selektive kontrolstrukturer. Et eksempel på en node i træet kunne være et if-statement. Et if-else statement har 2 branches som koden kan udføres. Disse vil kunne blive repræsenteret som 2 seperate nodes, derudover vil betingelsen der skal testes kunne blive repræsenteres som 1 seperat node.

\noindent Et eksempel på et abstract syntax tree kan ses i figur \ref{fig:exampletree}.

\tikzfigure{Figurer/TikZ/Tree.tex}{Eksempel på et \gls{ast}}{exampletree}

\noindent Det er muligt at gennemløbe træet på forskellige måder. En af måderne er vha. visitor-mønstret som forklares nærmere i afsnit \ref{sct:visitorSableCC}. En anden måde er vha. metoder i alle træ noderne også kaldet den objektorienterede metode. Denne metode har en metode til hvert step i compileren i trænoderne. Den objektorienterede metode er i store sprog med  store abstracte syntakstræer upraktisk, da til hver trin er i mange forskellige klasser. Derudover er metoden også mindre egnet til gennemløb af træet, da dette ikke på samme måde som ved visitor mønstret kan defineres generelt. Den objektorienterede metode har dog den fordel at det er hurtigere at implementere for mindre compilere, hvis det abstrakte syntakstræ bliver konstrueret uden brug af værktøjer.

\subsubsubsection{Top down/buttom up}
Konstruktionen af det abstrakte syntakstræ bliver udført af parseren. Der findes overordnet 2 forskellige metoder til at konstruere et abstrakt syntakstræ. Den ene metode er top down parsing, som konstruerer det abstrakte syntakstræ fra toppen af. Den anden metode er bottom up parsing der konstruerer fra bunden.

For at konstruerere det abstrakte syntax træ er det i nogle tilfælde et krav at kigge på flere tokens af gangen for at finde den korrekte del af sproget. Dette kaldes også lookaheads. Forskellen på de forskellige typer af sprog er hvor mange lookaheads de benytter og om de benytter top down eller buttom up parsing. Dette antydes af tallet efter sproget eks. LR(k), kan tage op til k lookaheads.

\subsubsubsection{Tvetydig grammatik}

\noindent En grammatik for et sprog kan også være tvetydig, hvis det er muligt at fremstille 2 forskellige syntaks træer ud fra en grammatik. Et eksempel på en tvetydig grammatik kunne være gramatikken i kodestykke \ref{code:unambigity}.

\SCC{Kode/CFG/Ambiguity.scc}{Tvetydig grammatik}{unambigity}

\noindent Grammatikken i kodestykke \ref{code:unambigity} definerer en simpel lommeregner der kun tager plus og gange, dog hvis der er mere end 1 operatore i udtrykket er det ikke defineret om grammatikken skal udføre udtrykket til venstre eller højre først. Dette vil derfor generere følgende to abstrakte syntax træer ud fra følgende udtryk 3 * 3 + 3, som ses på figur \ref{fig:unambiguous}.

\tikzfigure{Figurer/TikZ/AmbiguityExample.tex}{Eksempel på parse tree for en tvetydig grammatik}{unambiguous}

\noindent For at løse dette problem er det nødvendigt at definere rækkefølgen ved at tilføje en regel mere. Et eksempel hvordan følgende problem kan løses vises i kode \ref{code:fixedunambigity}
Dette tvinger altså parseren til at generere det abstrakte syntax træ som vist på figur \ref{fig:fixedunambiguous}.

\SCC{Kode/CFG/AmbiguityFixed.scc}{Ikke tvetydig grammatik}{fixedunambigity}
\tikzfigure{Figurer/TikZ/AmbiguityExampleFixed.tex}{Eksempel på parse tree for en ikke tvetydig grammatik}{fixedunambiguous}

\subsubsubsection{Finite automata}
Finite automata, på dansk også kaldet endelig tilstandsmaskine, kan bruges til at beskrive forskellige stadier et program kan gennemgå. Der skilnes mellem to forskellige automata - \gls{dfa} og \gls{nfa}. Da \gls{nfa} er en overbygning på \gls{dfa}, indledes afsnittet med en grundig forklaring og definition af \gls{dfa}, som der efterfølgende bygges videre på for at opnå det nødvendige teoretiske grundlag til implementation af en parser.\\

\noindent \gls{dfa} er kendetegnet ved ikke at have nogen hukommelse om tidligere stadier, samt kun én mulighed for at gå til et andet stadie afhængig af det input den modtager.

\tikzfigure{Figurer/TikZ/SimpleDFA.tex}{En simpel DFA, kaldet $M_1$}{simpledfa}

\noindent På figur \ref{fig:simpledfa} ses \gls{dfa}'en kaldet $M_1$, som vil blive beskrevet sammen med gennemgangen af den relevante teori. En \gls{dfa} kan beskrives med en 5-tuple, bestående af \[M = (Q, \Sigma, \delta, q_0, F)\]

\begin{itemize}
    \item $Q$ angiver et sæt bestående af alle tilstande i \gls{dfa}'en.\\
        $Q = \{q_0, q_1\}$
    \item $\Sigma$ angiver alfabetet - altså, de tegn der er tilladt som input.\\
        $\Sigma = \{0, 1\}$
    \item $\delta: Q \times \Sigma \rightarrow Q$ kaldes transitionsfunktionen, og angiver hvilket det næste stadie afhængigt af nuværende stadie og input. $\delta$ for $M_1$ ses på tabel \ref{tab:transfunk_m1}
    \item $q_0 \in Q$ angiver startstadiet.\\
        $q_0 = q_0$
    \item $F \subseteq Q$ angiver sættet af \textit{accept states}. Hvis en streng ender i et accept state, er strengen accepteret.\\
        $F = \{q_1\}$
\end{itemize}

\begin{table}[H]
    \centering
        \begin{tabular}{ c|c c }
        \centering
            $\delta$ & 0 & 1\\ \hline 
            $q_0$ & $q_0$ & $q_1$\\
            $q_1$ & $q_0$ & $q_1$\\
        \end{tabular}
    \caption{Transitionsfunktion for $M_1$}
    \label{tab:transfunk_m1}
\end{table}\sfix{Mangler der noget her?}

\subsubsubsection{Regular Expressions}
Regular expressions hænger tæt sammen med regular languages - ethvert sprog, som er regular, kan nemlig beskrives med en regular expression. Det er dog ikke her hovedvægten bliver lagt, da det er mere relevant at komme ind på regular expressions i programmeringssammenhæng. Her kan det bruges til at genkende "mønstre"\mbox{}, som er yderst relevant i forbindelse med scanneren. 

Det smarte ved regular expressions er altså at disse mønstre kan skrives utroligt kompakt. Et eksempel kunne være 

$$ \{w \in \{0, 1\}^* / w = 0^m\; 1\; 0^n, m,n \geq 0\} $$

\noindent I dette eksempel vil ord som 1, 01, 10, 010, 0100, ... være indeholdt i dette sprog. En meget mere kompakt for af dette, kan skrives som regular expression vha. $ 0^* 1\; 0^* $, som siger at der skal være nul, en eller flere nuller efterfulgt af et enkelt et-tal og derefter nul, en eller flere nuller igen. Det er desuden også muligt at bruge $0^+$, hvilket betyder at der skal være en eller flere. Tages der udgangspunkt i eksemplet før, og ændrer det til $0^* 1\; 0^+$, vil det nu betyde at ord som 1 og 01 ikke er i sproget, da ordet skulle slutte med mindst ét nul. Det er også muligt at bruge operatorer som $\cup$ og $\cap$ til at sammensætte flere udtryk. Der vil blive taget udgangspunkt i dette eksempel

$$ \{w \in \{a, b\}^* / w \text{ starts with }b \text{ or end with }bb\} $$

\noindent hvilket kan omskrives til $b(a \cup b)^* \cup (a \cup b)^* bb$. Kort fortalt siger denne regular expression at der findes to muligheder. Mulighed siger at der først skal være ét b og derefter må a'er og b'er blandes på vilkårlige måder. Den anden mulighed er først a'er og b'er blandet - og derefter to b'er. Altså præcist hvad den anden definition beskrev.

Det sidste der kan beskrives om regular expressions, er at disse uden videre kan omdannes til en \gls{nfa} ved at følge en simpel algoritme. Algoritmen vil ikke blive forklaret yderligere, men et simpelt eksempel vil følge udfra $((a^*b) \cup aa)^*$. Den resulterende NFA ses på figur \ref{fig:regextonfa}

\tikzfigure{Figurer/TikZ/RegexToNFA.tex}{Regular expression til NFA}{regextonfa}

\noindent \textbf{Formel definition af NFA i figur \ref{fig:regextonfa}}\\
\noindent $Q$ = \{$q_0$, $r_0$, $r_1$, $s_0$, $s_1$, $s_2$\}\\
\noindent $\Sigma$ = \{$\epsilon$, $a$, $b$\}\\
\noindent $\delta$ = Se tabel \ref{tab:regextonfa}\\
\noindent $q_0$ = $q_0$\\
\noindent $F$= \{$q_0$\}\\

\begin{table}[H]
\centering
\footnotesize
\rowcolors{2}{black!5}{white}
\begin{tabular}{l@{\hskip\tabcolsep\vrule width 1pt\hskip\tabcolsep}l|l|l|l|l|l}

$\delta$   & $q_0$          & $r_0$     & $r_1$     & $s_0$     & $s_1$     & $s_2$ \\ \bottomrule
$\epsilon$ & $\{r_0, s_0\}$ &           & $\{q_0\}$ &           &           & $\{q_0\}$ \\
$a$        &                & $\{r_0\}$ &           & $\{s_1\}$ & $\{s_2\}$ &       \\
$b$        &                & $\{r_1\}$ &           &           &           &

\end{tabular}
	\caption{Transitionsfunktion (alle tommer celler angiver den tomme mængde)}
    \label{tab:regextonfa}
\end{table}

%\figur{Figurer/MTAST.png}{Abstrakt syntakstræ baseret på kodeeksempel \ref{code:minitriangleforscanner}}{MTAST}{1.0}

%\noindent På figur \ref{fig:MTAST} ses et sådant træ for koden vist i eksempel \ref{code:minitriangleforscanner}. For at forstå hvordan træet er bygget op, er det dog nødvendigt også at kende til \gls{cfg}. Denne forklares i dybden i afsnit x.x\mfix{Mangler ref}, men den konkrete \gls{cfg} for Mini Triangle kan ses i bilag \ref{bil:minitriangle}. Eksempelvis ses det øverste i den øverste del af træet at \textit{single-Command} består af "\textit{let} Declaration \textit{in} single-Command"\mbox{}, hvilket passer med grammatikken.