\subsubsection{Implementation}

\mfix{Tjek ref når alt er flyttet}
I afsnit \ref{ssec:toolsforcc} omtales flere forskellige værktøjer til generering af compilere (også kaldet CompilerCompilers). Det er blevet valgt at gøre brug af SableCC, da denne indeholder en del funktioner som er nyttige for udarbejdelsen af PLC++. Blandt disse kan nævnes at det er en \gls{lalr}1-parser og derudover genereres SableCC et \gls{ast} med indbyggede metoder til at gennemløbe træet ved hjælp af Visitor Mønsteret (yderligere forklaret i afsnit \ref{sec:visitor}).

SableCC har desuden den fordel\sfix{Kan også være en ulempe} at den både genererer en scanner og parser. For at kunne gøre dette, er SableCC afhængig af en konfigurationsfil som indeholder den kontekst-fri grammatik samt hvordan det abstrakte syntaks træ bliver genereret af SableCC.

SableCC's konfigurationsfil kan indeholde Helpers, Tokens, Ignored Tokens, Productions og Abstract syntax tree.

Helpers er en række hjælpe grammatik der bruges i tokens, i tilfælde af ens kode. Dette kunne eks. være helperen digit der kan være alle tal mellem 0 og 9. Helperen digit bliver brugt til integer\_literal og decimal\_literal, dermed undgår man at skrive den samme gramatik flere gange.

Tokens indeholder reglerene for lexeren. Tokens er alle mindre dele af et sprog, som bruges af parseren til at lave det abstrakte syntaks træ. Ved at bruge kommandoen \textit{--verbose} til compileren vil den printe alle tokens.

Ignored tokens definerer hvilke tokens parseren skal ignorere under fremstillingen af det abstrakte syntaks træ.

Productions definerer alle regler for parseren. Produktionsreglerne definerer også hvordan reglerne skal bruges til at generere det abstrakte syntax træ. Hvis intet abstrakt syntax træ er blevet defineret laver SableCC sit eget abstrakte syntax træ ud fra productions reglerne. Det er dog i de fleste tilfælde smart at lave sit eget abstrakt syntax træ, grundet at simple matematik operationer såsom gange og plusse kan lave et meget kompliceret abstrakt syntax træ, da grammatikken ikke må være unambigius. Productionreglerne refererer til det abstrakte syntaks træ vha. tuborgklammer. \sfix{Kan det defineres mere klart}

Abstract syntax tree definerer som navnet antyder hvordan det abstrakte syntaks træ ser ud og hvilke subnoder hver enkelt node har.

Et udsnit af grammatikken anvendt til at generere parser/scanner til PLC++, ses på kode \ref{code:cfgudsnit}

Gramatikken SableCC bruger til at lave scanneren og parseren

\SCC{Kode/Udsnit.scc}{Udsnit af CFG i SableCC-syntax}{cfgudsnit}

\noindent Det er værd at bemærke at rækkefølgen ikke er bevaret i kodeeksemplet, men er opsat efter forklaringen.

På linje 1-2 ses helperen digit som bruges som en "hjælpe" regex der kan bruges til definationen af tokens.

På linje 4-8 ses en række tokens som lexeren skal genkende. Herunder parenteser, og operatoren og eller operatoren samt while keywordet.

På linje 12-19 en del af production reglen for et statement. I følgende eksempel er medtaget hvordan et scope bliver defineret (linje 14-15) samt et while statement (linje 17-18). Det kan ses på linje 13 at den tilhørende overklasse node i det abstrakte syntaks træ hedder statement (udtrykt i tuborgklammerne). På linje 15 kan det derudover ses at scope refererer til statement.scope. Med andre ord, superklassen på noden er statement og den konkrete node i det abstrakte syntaks træ er scope. Noden tager også et array af statements med som parameter. SableCC genkender et array vha. hårde paranteser. Bemærk den specielle syntaks med statement.statement. Dette betyder at vi tager produktionsreglen statement og referer til den abstrakte syntaks træs node statement som produktionsreglen genererer.

På linje 21-31 ses 2 expressions herunder and og or expression. For at specialisere precendence i SableCC er man nødt til at lave denne særlige konstruktion der gør sådan at and expression bliver prioriteret højere end or expression (En af ulemperne ved SableCC). Dette giver dog som standard et meget grimt abstrakt syntaks træ, da alle faktorer også bliver en seperat node. Eksempelvis for at lave en andExpr skal man først have en factorOrExpr node og derefter en andAndExpr node. Derfor kan man lave sit eget abstrakte syntaks træ som kun indeholder en expr node. En meget lille del af expr node i det abstrakte syntaks træ kan ses på linje 33-37. Her vises compareAndExpr og compareOrExpr. Som der refereres til i produktionsreglerne.

%På linje 1-2 ses definitionen for et \textit{while\_statement} - altså en løkke af typen while. Teksten i tuborgklammerne angiver navnet, som kan bruges til intern brug i programmet. Herefter fortæller grammatikken hvad et \textit{while\_statement} består af. Det første, \textit{while\_keyword}, er defineret på linje 4 som værende teksten "while"\mbox{}. Da det ikke er muligt at skrive keywords på samme måde som i \gls{bnf}, er det nødvendigt at definere alle i starten af konfigurationsfilen.

%Et eksempel på dette kommer også til udtryk ved \textit{l\_par} og \textit{r\_par} som henholdsvis dækker og venstre og højre parentes - disse er defineret på linje 6-7 i kodeeksemplet. Imellem de to parenteser findes \textit{expr}, en expression. Definitionen på denne ses i linje 9-12, som fortæller at det kan være to expressions sammenlignet ved hjælp af \textit{and\_operator} eller \textit{or\_operator}. Produktionen til \textit{expr2} er udeladt i dette kodeeksempel, men kan findes i den fulde udgave af SableCC-konfigurationen i bilag \ref{bil:sablecc}.

%Det sidste element er \textit{scope}, som på linje 14-15 er defineret ved hjælp af nul eller en \textit{statements} omgivet af tuborgklammer.\\

\subsubsubsection{Dangling else problematik}


\subsubsubsection{SableCC's implementation af lexer og parser}
\noindent Når compileren skal læse kildekoden, for at få dette opsat til tokens, er der, som nævnt i afsnit x.x\mfix{ref} flere måder at implementere det på. I compileren til PLC++ er det blevet implementeret ved hjælp af state machines. Konkret genereres først en \gls{nfa}, som efterfølgende omdannes til en \gls{dfa}.

\tikzfigure{Figurer/TikZ/SableCC_NFA.tex}{En NFA genereret af SableCC}{sableccnfa}

\noindent \textbf{Formel definition af NFA i figur \ref{fig:sableccnfa}}\\
\noindent $Q$ = \{$s$, $q_1$, $q_2$, $q_3$, $q_4$, $q_5$, $q_6$, $q_7$, $q_8$, $q_9$, $q_{10}$, $q_{11}$, $q_{12}$, $q_{13}$, $f$\}\\
\noindent $\Sigma$ = \{$\epsilon$, $I$, $Q$, $M$, $A$, $\#$\}\\
\noindent $\delta$ = Se tabel \ref{tab:nfadelta}\\
\noindent $q_0$ = $s$\\
\noindent $F$= \{$f$\}\\


\begin{table}[H]
\centering
\footnotesize
\rowcolors{2}{blue!10}{white}
\begin{tabular}{l@{\hskip\tabcolsep\vrule width 1pt\hskip\tabcolsep}m{5em}|l|l|l|l|l|l|l|l|l|l|l|l|l|l}

$\delta$         & $s$              & $q_{1}$ & $q_{2}$ & $q_{3}$ & $q_{4}$ & $q_{5}$ & $q_{6}$ & $q_{7}$ & $q_{8}$ & $q_{9}$ & $q_{10}$ & $q_{11}$ & $q_{12}$ & $q_{13}$ & $f$ \\ \bottomrule
$\epsilon$ & \{$q_{1}$ ,$q_{3}$ ,$q_{5}$ ,$q_{7}$ ,$q_{10}$\} &   & $q_{13}$ &   & $q_{13}$ &   & $q_{13}$ &   &   & $q_{13}$ &    &    & $q_{13}$ &    &   \\ 
$I$          &                & $q_{2}$ &    &   &    &   &    &   & $q_{9}$ &    &    &    &    &    &   \\ 
$Q$          &                &   &    & $q_{4}$ &    &   &    &   &   &    &    & $q_{12}$ &    &    &   \\ 
$M$          &                &   &    &   &    & $q_{6}$ &    &   &   &    &    &    &    &    &   \\
$A$          &                &   &    &   &    &   &    & $q_{8}$ &   &    & $q_{11}$ &    &    &    &   \\ 
\#         &                &   &    &   &    &   &    &   &   &    &    &    &    & $f$  &   \\
\end{tabular}
	\caption{\textit{Transitionsfunktion til NFA (alle tommer celler angiver den tomme mængde)}}
    \label{tab:nfadelta}
\end{table}

\noindent På figur \ref{fig:sableccnfa} ses hvordan en \textit{port\_identifier} (defineret på linje 20 i kode \ref{code:cfgudsnit}) genkendes. Hvis der i programmet angives AQ\#7 arbejdes der med analoge output-port 7. I \gls{nfa}'en starter man i state \textit{s}, hvorefter der foretages et ikke-deterministisk valg om at gå videre til state  \textit{q\textunderscript{10}}. Derefter læses bogstavet A, som får maskinen til at gå til \textit{q\textunderscript{11}}. Efter et Q bliver state \textit{q\textunderscript{12}} sprunget over, da $\epsilon$ (den tomme streng) lader den gå videre til state \textit{q\textunderscript{13}}. Efter at have læst \# kommer den i det sidste state, \textit{f}, som er en accept state - og ordet er derved accepteret. \\

\noindent Som tidligere nævnt, er dette ikke den konkrete grammatik, men opsætningen af denne i SableCC. Den korrekte grammatik, skrevet i \gls{ebnf} ses på grammatik \ref{gra:udsnit}. Den fulde kontekstfri grammatik findes i bilag \ref{bil:cfg}

\input{Kode/CFG/Udsnit.tex}

\noindent Ud fra grammatikken kan SableCC generere et \gls{ast}. Der vil her blive givet et eksempel ved hjælp af dette udtrykket, som ses i kode \ref{code:exprforast}

\AnsiC{Kode/ExprForAST.c}{Udtryk der bruges til at bygge AST}{exprforast}

\noindent Der bruges left-most derivation til at bygge træet. Dette vil sige at reglerne (også kaldet produktioner) udvides fra venstre mod højre. Ved at bygge træet, kan det også give mulighed for at opdage tvetydig grammatik - dette ses ved at det er muligt at lave to forskellige \gls{ast}'er ud fra samme regler og sætning.

\tikzfigure{Figurer/TikZ/AST.tex}{AST fra PLC++}{astexample}

\noindent Træet er nu bygget, og alt er klar til at gå videre til næste trin - at dekorere træet med typer i Context Analysis.