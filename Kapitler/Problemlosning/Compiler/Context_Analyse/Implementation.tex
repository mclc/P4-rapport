\subsubsection{Implementation}
Context analysen i compileren udviklet er blevet delt op i 2 mindre dele; herunder scope checker og type checker. Før vi kan kigge på scope checkeren skal vi først kigge på hvordan visitor mønstret er implementeret i SableCC.

\subsubsubsection{Visitor mønstret i SableCC}\label{sct:visitorSableCC}
SableCC generer som standard et interface med navn Analytics som implementerer interfacet Switch. Analytics interfacet indeholder en metode for alle noder og tokens med præfixet case. (Se klassediagram på figur \ref{fig:sableCCAnalytics})

Alle noder implementer interfacet Switchable som indeholder en metode med navn apply, som tager en Switch som input parameter. Noden skal dermed kalde sin egen metode i Analytics interfacet. Eksempel kalder noden ASubExpr metoden caseASubExpr i Analytics interfacet som ses i kode \ref{code:nodeVisitorJava}

\Java{Kode/NodeVisitor.java}{Implementering af interfacet Switchable i noderne genereret af SableCC}{nodeVisitorJava}

Dermed er det muligt at lave en AnalyticsAdapter som implementer Analytics interfacet. Alle case metoder kalder en metode kaldet defaultCase som tager noden som input parameter. AnalyticsAdapter implementerer også metoder til at gemme data om hver node i en hashtable. 

Til at gennemløbe træet genererer SableCC en klasse med navn DepthFirstAdapter som nedarver fra AnalyticsAdapter klassen. DepthFirstAdapter overskriver alle case funktioner således at alle case funktioner kalder apply med DepthFirstAdapteren som argument på alle subnoder i den pågældende node. Dermed har vi en simpel træløbning da apply kalder den pågældende case funktion i klassen (Se klassediagram på figur \ref{fig:sableCCAnalytics}). For at have mere fleksibilitet oprettes også en in og en out metode for alle noder. Case metoden kalder nu først in metoden, dernæst apply(this) på alle subnoder og til slut out metoden. Det er dermed eksempelvis nu muligt at bruge en stack til at håndtere matematiske operationer kun ved at overskrive out metoderne.

Processen med at gennemløbe træet startes ved at kalde apply på start noden som genereres under kørslen af parseren, metoden apply tager som input parameter et objekt der implementer Analytics interfacet (Switchable for at være nøjagtig, dog castes der altid til Analytics og der vil dermed blive kastet en ClassCastException hvis argumentet er et objekt af typen Switchable).

\tikzfigure{Figurer/TikZ/KlassediagramSabelCC.tex}{Klassediagram for SableCC's visitor mønster}{sableCCAnalytics}{1.0}

SableCC's visitor mønster er nu forklaret som skal bruges til scope checkeren, type checkeren og code generation.

\subsubsubsection{Scope checker}
Scope checkerens opgaver er at tjekke at de konkrete identifiers kan tilgås i den konkrete kontekst. Dog skal der her tages højde for om der er statisk scope eller dynamisk scope. PLC++ specikationen siger at der skal være dynamisk scope for funktioner, structs og globale variabler, mens der skal være statisk scope inden for alle funktioner. Ved at have dynamisk scope for funktioner, og structs kan vi desuden slippe for header filer, prototyper og en hel masse begynder programmør fejl.

For at håndtere dynamisk scope køres først en præprocessor der indlæser funktioner, structs og globale variabler ind i symboltabellen. Dernæst køres scopecheckeren der tjekker hver gang der stødes på en identifier om den konkrete identifier eksisterer i det pågældende scope. Den håndterer også oprettelsen af lokale variabler, således det ikke er muligt at bruge en lokal variabel der ikke er blevet deklareret endnu (static scope).

For at forhindre at alle funktioner, structs og globale variabler bliver registret to gange (både i præprocessoren og scopecheckeren) overrides case metoderne fra DeptFirstAdapteren og de bliver sat til at gøre ingenting.

\subsubsubsection{Type checker}
Type checkerens opgave er at tjekke at alle expressions er gyldige, eksempelvis at det ikke er tilladt at addere 2 boolske værdier. Derudover skal alle metodekald også tjekkes om de er gyldige, samt alle statements der har et krav om at have en specifik type af expr. Eksempelvis kræver et if-statement en boolsk datatype som condition.

Expressions kan evalueres på en stack vha. DeptFirstAdapterens out metoder. Eksempelvis vil udtrykket 3 + (5 * 2) blive evalueret som vist på figur \ref{fig:stackExprEval}:

\figur{Figurer/Billeder/stack.png}{Evaluering af udtrykket 3 + (5 * 2) vha. en stack}{stackExprEval}{0.7}

Dette gøres ved out metoderne som beskrevet i afsnit \ref{sct:visitorSableCC} på det parsede abstrakte syntaks træ som kan ses på figur \ref{fig:evaluationAST}
\tikzfigure{Figurer/TikZ/EvaluationOfSimpleMath.tex}{Abstrakt syntaks træ for udtrykket 3 + (5 * 2)}{evaluationAST}

Stacken vil dermed indlæse de 3 første tal, dernæst gange de 2 seneste tal sammen og ligge på stacken og til slut addere det første tal med resultatet af multiplikationen af 5 og 2. Udtrykket kan dermed opstilles til 3 5 2 * +. Denne notation kaldes også reverse polish notation \cite{CraftingCompiler_2009}.

I typecheckerens eksempel er vi dog i stedet nødt til at registrere typen af tallene således at true + 1 er et ugyldigt input, hvorimod 1 + 1 er gyldigt. Dette gøres på samme måde med stacken bortset fra at vi ligger et objekt på stacken der indikerer om det er en boolsk værdi eller en tal værdi. Et eksempel på hvordan kostanter bliver pushed til stacken, samt hvordan de 2 seneste værdier sammenlignes ved en større end expression kan ses i kodeeksempel \ref{code:exprTypeEvaluator}

\Java{Kode/ExprTypeEvaluator.java}{Push af konstanters type på stacken som giver mulighed for typecheck}{exprTypeEvaluator}

