\subsubsection{Implementation}
\label{ssec:contextimple}
Context analysen implementeret i compileren, består af to dele; en scope checker og en type checker. Scope checkeren opretter forskellige miljøer for forskellige scopes og tildeler symbolerne til de miljøer der koresponderer til deres scope. På den måde kan symboler fra utiltænkte miljøer ikke tilgåes.

Type checkeren kontrollerer at de typer der benyttes i udtryk og statements er ækvivalente med de typer som udtrykene og statementsne accepterer. Men før det er muligt at kigge på scope- og type checker skal visitor mønstret, som det er implementeret i SableCC gennemgås.

\subsubsubsection{Visitor mønstret i SableCC}\label{sct:visitorSableCC}
SableCC generer som standard et interface ved navn \textit{Analytics} som implementerer interfacet \textit{Switch}. \textit{Analytics} interfacet indeholder en metode for hver mulig node eller token i programmet, med præfixet case, som set i klassediagrammet på figur \ref{fig:sableCCAnalytics}.

 Alle noder i \gls{ast} implementerer interfacet \textit{Switchable}, som har en metode ved navn \textit{apply}, som tager en klasse der tager \textit{Switch} som input parameter. Noden skal dermed kalde sin egen metode i \textit{Analytics} interfacet. Et eksempel er at noden \textit{ASubExpr} kalder metoden \textit{caseASubExpr} i \textit{Analytics} interfacet som ses i kodeeksempel \ref{code:nodeVisitorJava}

\Java{Kode/NodeVisitor.java}{Implementering af interfacet \textit{Switchable} i noderne genereret af SableCC}{nodeVisitorJava}

\noindent Dette gør det muligt at lave en \textit{AnalyticsAdapter} som implementerer \textit{Analytics} interfacet. Alle case metoder i \textit{Analytics} interfacet kalder en metode ved navn \textit{defaultCase}, som tager noden som input parameter. Metoden \textit{defaultCase} gør som standard ikke noget, metoden er dog virtual og kan overrides. \textit{AnalyticsAdapter} implementerer derudover også metoder til at gemme data for hver node i en hashtable.

%\bigskip

 Til at gennemløbe træet genererer SableCC en klasse med navn \textit{DepthFirstAdapter} som nedarver fra \textit{AnalyticsAdapter} klassen. \textit{DepthFirstAdapter} overskriver alle case funktioner på noder (ikke tokens) således, at alle case funktioner kalder \textit{apply} med \textit{DepthFirstAdapteren} som argument på alle subnoder, fra venstre mod højre, i den pågældende node. Det bruges dermed til en simpel \gls{dfs} (Se klassediagram på figur \ref{fig:sableCCAnalytics}). For at have øge fleksibiliteten oprettes også en in og en out metode for alle de overskrevne case metoder. Case metoden kalder nu først in metoden, dernæst \textit{apply(this)} på alle subnoder og til sidst out metoden. Man starter hele denne process ved at kalde \textit{apply} metoden på en rod node, som genereres under kørsel af parseren.
% Det er dermed muligt at bruge en stack til at håndtere matematiske operationer kun ved at overskrive out metoderne.

\bigskip

%\noindent Processen med at gennemløbe træet startes ved at kalde apply på start noden som genereres under kørslen af parseren, metoden apply tager som input parameter et objekt der implementer Analytics interfacet (Switchable for at være nøjagtig, dog castes der altid til Analytics og der vil dermed blive kastet en ClassCastException, hvis argumentet er et objekt af typen Switchable).

\tikzfigure{Figurer/TikZ/KlassediagramSabelCC.tex}{Klassediagram for SableCC's visitor mønster}{sableCCAnalytics}{1.0}

\noindent SableCC's visitor mønster er nu forklaret som skal bruges til scope checkeren, type checkeren og code generation.

\subsubsubsection{Scope checker}
Scope checkerens opgaver er at tjekke at de konkrete identifiers kan tilgås i den konkrete kontekst. Dog skal der her tages højde for om der er statisk scope eller dynamisk scope. PLC++ specifikationen siger at der skal være dynamisk scope for funktioner, structs og globale variabler, hvis man vil bruge de indbyggede funktioner til variabler, mens der skal være statisk scope inden for alle funktioner. Ved at have dynamisk scope for funktioner og structs er det muligt at slippe for header filer, prototyper og dermed også nogle fejl, hvis headerfilerne bliver konfigurereret forkert.\\

\noindent For at håndtere dynamisk scope køres først en præprocessor der indlæser funktioner, structs og globale variabler ind i symboltabellen. Dernæst køres scopecheckeren, der tjekker hver gang der stødes på en identifier om den konkrete identifier eksisterer i det pågældende scope, hvis den allerede eksisterer rapporterer compileren om fejl. Scopecheckeren håndterer også oprettelsen af lokale variabler, således det ikke er muligt at bruge en lokal variabel der ikke er blevet deklareret endnu (static scope).\\

\noindent For at forhindre at alle funktioner, structs og globale variabler bliver registret to gange (både i præprocessoren og scopecheckeren) overrides case metoderne fra DepthFirstAdapteren for de tilsvarende funktioner, og de bliver sat til at udføre \textit{caseDefault}.

\subsubsubsection{Type checker}
Type checkerens opgave er at tjekke at alle expressions er gyldige, eksempelvis er det ikke er tilladt at addere to boolske værdier. Derudover skal alle metodekald også tjekkes om de er gyldige, samt alle statements der har et krav om at have en specifik type af expressions. Eksempelvis kræver et if-statement en boolsk datatype som betingelse.

Expressions kan evalueres på en stack ved hjælp af \textit{DepthFirstAdapteren}'s out metoder. Eksempelvis vil udtrykket 3 + (5 * 2) blive evalueret som vist på figur \ref{fig:stackExprEval}:

\figur{Figurer/Billeder/stack.png}{Evaluering af udtrykket 3 + (5 * 2) ved hjælp af en stack}{stackExprEval}{0.7}

\noindent Dette gøres ved brug af out metoderne som beskrevet i afsnit \ref{sct:visitorSableCC}. Det parsede \gls{ast} kan ses på figur \ref{fig:evaluationAST}
\tikzfigure{Figurer/TikZ/EvaluationOfSimpleMath.tex}{\gls{ast} for udtrykket 3 + (5 * 2)}{evaluationAST}

Stacken vil dermed indlæse de 3 første tal, dernæst gange de 2 seneste tal sammen og ligge på stacken. Til slut bliver det første tal adderet med resultatet af multiplikationen af 5 og 2. Udtrykket kan dermed opstilles til 3 5 2 * +. Denne notation kaldes også omvendt polisk notation \cite{CraftingCompiler_2009} eller postfix notation.

I typecheckerens eksempel er det nødvendigt at registrere typen af tallene således at true + 1 er et ugyldigt input, hvorimod 1 + 1 er gyldigt. Dette gøres på samme måde ved hjælp af stacken bortset fra at der ligger et objekt på stacken, der indikerer hvad typen af værdien er. I kodeeksempel \ref{code:exprTypeEvaluator} kan ses et eksempel på hvordan konstanter bliver pushed til stacken, samt hvordan de 2 seneste værdier sammenlignes ved en større end operator.  

\Java{Kode/ExprTypeEvaluator.java}{Push af konstanters type på stacken som giver mulighed for typecheck}{exprTypeEvaluator}

