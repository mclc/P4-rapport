\subsubsection{Resultater}
For at komme frem til resultater som kunne kompilere på en \gls{plc}, og gør hvad kildekoden dikterer i følge semantikken, blev vi nød til at lave nogle interessante oversætninger som i løbet at dette afsnit vil blive belyst.

\begin{table}[H]
    \centering\ttfamily
    \begin{tabular}{l|l l}
        PLC++       & \gls{il} \\\hline
        i = 1 + 3;  & MOVL \&1 W402     &// Push(1)\\
                    & MOVL \&3 W404     &// Push(3)\\
                    & + W404 W402 W402  &// Push(Pop() + Pop())\\
                    & MOVL W402 i       &// i = Pop()
    \end{tabular}
    \caption{Eksemple på kode som compileren kunne generere.}
    \label{tab:codegenExample}
\end{table}

\noindent Fra eksemplet i tabel {\ref{tab:codegenExample} kan man se hvordan at koden finder deler udtrykket \textit{i = 1 + 3} op i flere dele. Alle disse dele stammer fra det \gls{ast} der blev genereret til dette stykke kode, og kan ses på figur \ref{fig:codegenAST}. En ting der er vigtigt at bemærke er at visitoren laver en \gls{dfs} hvilken normalt går fra venstre mod højre, men for at kunne tilskrive værdien af venstre udtryk af AAssignExpr til højre udtryk, bliver den højre først evalueret. Dette er én af de modifikationer som \textit{CodeGenerator} visitoren har til standard \gls{dfs}.

\tikzfigure{Figurer/TikZ/CodeGenExampleAST.tex}{\Gls{ast} for samme stykke kode som i tabel \ref{tab:codegenExample}.}{codegenAST}

\begin{table}[H]
    \centering\ttfamily
    \begin{tabular}{l|l|l l}
         &PLC++                 & \gls{il} \\\hline
        1&if(true)\{            & SET W402.00       &// Push(true)\\
        2&  i = 1;              & CJP \#0           &// Jump if false to JME \#0\\
        3&\} else \{            & LD W402.00        &// Start a new ladder\\
        4&  i = 0;              & // Udeladt: i = 0\\
        5& \}                   & JMP \#1           &// Jump to JME \#1\\
        6&                      & JME \#0           &\\
        7&                      & LD P\_FirstCycle  &// Start a new ladder\\
        8&                      & // Udeladt: i = 1\\
        9&                      & JME \#1
    \end{tabular}
    \caption{Eksemple på hvordan kode generatoren håndtere et if-else statement.}
    \label{tab:codegenIf}
\end{table}

\noindent Et ligende eksempel er når man compilere en if-else kæde som set i tabel \ref{tab:codegenIf}. Her bliver der byttet rundt på række følgen af \textit{Do something} og \textit{Do something else}, da man ellers skulle invertere resultatet fra betingelsen, i dette tilfælde \textit{true}, fordi instruktionen \textit{CJP} bliver kun udført hvis den modtager et lavt signal.

\tikzfigure{Figurer/TikZ/CodeGenIfAST.tex}{\Gls{ast} for samme stykke kode som i tabel \ref{tab:codegenIf}. Detalier om hvad der sker med tokens inden i løkker er udeladt.}{codegenIfAST}

\noindent En sidste metode der er interessant at tage fat i er genereringen af arrays, fordi \gls{plc}'er ikke har pointere på samme måde som man ville have dem i fx Assembly og C. Det betyder at PLC++ compileren bliver nød til at finde på et alternativ.

\begin{table}[H]
    \centering\ttfamily
    \begin{tabular}{l|l|l l}
         &PLC++       & \gls{il} \\\hline
        1&i = A[2];   & MOVL A W402       &// Push(address of first element in A)\\
        2&            & MOVL \&2 W404     &// Push(2)\\
        3&            & * W404 \&2 W404   &// Scale to word size\\
        4&            & + W404 W402 W402  &// Add offset and first element\\
        5&            & MOVL W402 D24     &// Move to data memory\\
        6&            & MOVL @D24 W402    &// Push the value D24 points to\\
        7&            & MOVL W402 i       &// i = Pop()
    \end{tabular}
    \caption{Eksemple på hvordan kode generatoren ville generere en værdi fra et array.}
    \label{tab:codegenArray}
\end{table}

\noindent Arrays i programmet bliver håndteret ved at en mængde adresser bliver reserveret til dataen og et symbol bliver indsat der holder værdien af den første adresse af arrayet. Måden hvorpå værdierne i arrayet kan ses i tabel \ref{tab:codegenArray}. Dette forgår ved at den henter addressen på første element og hvor langt den skal gå fra den (linje 2-3), ligger dem sammen (linje 4) og bruger resultatet som en pointer til at hente værdien i arrayet (linje 6).

%\subsubsection{Implementation}
Måden at kode generatoren blev implementeret er som før nævnt gennem et visitor mønster. Klassen hedder CodeGenerator og består at de funktioner visitor mønsteret diktere den skal have, og en funktion til at skrive resultatet til en fil; \textit{Emit}.

\Java{Kode/CodeGeneratorEmit.java}{Emit funktionen fra CodeGenerator klassen}{emit}

Emit funktionen som set i kodeeksempel \ref{code:emit} er relativ simpel, den åbner eller lukker ikke for nogle af sine text writers. Den skriver bare til en af dem afhængig af en boolean. Grunden til dette er blandt andet at CX-Programmer som blev brugt til videre kompilering af programmet gemmer en symbol tabel, som PLC++ udnytter til at forøge læsbarheden af den kompilerede kode ved at erstatte vilkårlige adresser med variable navne. 

For at kunne bruge mange af de teknikker der allerede var udviklet til assembly compilere er det nødvendigt at have en stack. \gls{plc}en har en indebyggede stack som viste sig at være utilstrækkelig grundet at den ikke havde stackpointer, således at man ikke kunne tage de x'nd element. Derfor har PLC++ kompileren en indebygget stack, der bruger working memory området W400 - W512, som har en pointer således at man frit kan vælge fra stacken.

\Java{Kode/Stack.java}{Push()-funkionen fra Stack klassen}{push}

Klassen Stack sørger for dette med standard funktionerne man ville forvente af en stack data struktur push og pop. Hvor push funktionen kan ses i kodeeksempel \ref{code:push}. Her tager den hensyn til hvilken variable der bliver pushet til stacken, men i sidste ende kommer de alle til at være gemt som den største data type der er til gængelig på 32 bit. Det giver noget data spild men tilgengæld er \textit{pop()} funktionen kun en decrement af pointeren og returnering af værdien og så håndterer modtageren værdien.