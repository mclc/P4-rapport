\subsubsection{Resultater}
For at komme frem til resultater som kunne kompilere på en \gls{plc}, og gør hvad kildekoden dikterer i følge semantikken, blev vi nød til at lave nogle interessante oversætninger som i løbet at dette afsnit vil blive belyst.

\begin{table}[h]
    \centering\ttfamily
    \begin{tabular}{l|l l}
        PLC++       & \gls{il} \\\hline
        i = 1 + 3;  & MOVL \&1 W402     &// Push(1)\\
                    & MOVL \&3 W404     &// Push(3)\\
                    & + W404 W402 W402  &// Push(Pop() + Pop())\\
                    & MOVL W402 i       &// i = Pop()
    \end{tabular}
    \caption{Eksemple på kode som compileren kunne generere.}
    \label{tab:codegenExample}
\end{table}

Fra eksemplet i tabel {\ref{tab:codegenExample} kan man se hvordan at koden finder deler udtrykket \textit{i = 1 + 3} op i flere dele. Alle disse dele stammer fra det \gls{ast} der blev genereret til dette stykke kode, og kan ses på figur \ref{fig:codegenAST}. En ting der er vigtigt at bemærke er at visitoren laver en \gls{dfs} hvilken normalt går fra venstre mod højre, men for at kunne tilskrive værdien af venstre udtryk af AAssignExpr til højre udtryk, bliver den højre først evalueret. Dette er én af de modifikationer som \textit{CodeGenerator} visitoren har til standard \gls{dfs}.

\tikzfigure{Figurer/TikZ/CodeGenExampleAST.tex}{\Gls{ast} for samme stykke kode som i tabel \ref{tab:codegenExample}.}{codegenAST}

\begin{table}[h]
    \centering\ttfamily
    \begin{tabular}{l|l|l l}
         &PLC++       & \gls{il} \\\hline
        1&i = A[2];   & MOVL A W402       &// Push(address of first element in A)\\
        2&            & MOVL \&2 W404     &// Push(2)\\
        3&            & * W404 \&2 W404   &// Scale to word size\\
        4&            & + W404 W402 W402  &// Add offset and first element\\
        5&            & MOVL W402 D24     &// Move to data memory\\
        6&            & MOVL @D24 W402    &// Push the value D24 points to\\
        7&            & MOVL W402 i       &// i = Pop()
    \end{tabular}
    \caption{Eksemple på hvordan kode generatoren ville generere en værdi fra et array.}
    \label{tab:codegenArray}
\end{table}

Arrays i programmet bliver håndteret ved at en mængde adresser bliver reserveret til dataen og et symbol bliver indsat der holder værdien af den første adresse af arrayet. Måden hvorpå værdierne i arrayet kan ses i tabel \ref{tab:codegenArray}. Dette forgår ved at den henter addressen på første element og hvor langt den skal gå fra den (linje 2-3), ligger dem sammen (linje 4) og bruger resultatet som en pointer til at hente værdien i arrayet (linje 6).

\subsubsection{Implementation}
Måden at kode generatoren blev implementeret er som før nævnt gennem et visitor mønster. Klassen hedder CodeGenerator og består at de funktioner visitor mønsteret diktere den skal have, og en funktion til at skrive resultatet til en fil; \textit{Emit}.

\Java{Kode/CodeGeneratorEmit.java}{Emit funktionen fra CodeGenerator klassen}{emit}

Emit funktionen som set i kodeeksempel \ref{code:emit} er relativ simpel, den åbner eller lukker ikke for nogle af sine text writers. Den skriver bare til en af dem afhængig af en boolean. Grunden til dette er blandt andet at CX-Programmer som blev brugt til videre kompilering af programmet gemmer en symbol tabel, som PLC++ udnytter til at forøge læsbarheden af den kompilerede kode ved at erstatte vilkårlige adresser med variable navne. % er du med på vi tager skype møde i morgen claus?