\subsubsection{Baggrund}
Til at generere \gls{il}-koden blev der udviklet endnu en visitor. Denne vistors primære opgaver er at skrive \gls{il}-kode til en destinations fil som udføre samme opgave som beskrevet i kildekoden. Da \gls{il} minder om Assembly i syntaksen og tilgængelige instruktioner kan vi bruge mange teknikker og teorier fra andre compilere, der compilere til det sprog.

%\subsection*{Forskelle mellem \gls{il} \& Assembly}
Ud over de små syntaktiske forskelligheder så er gls{il} fokuseret på at værdierne skal kunne repræsenteres i den virkelige verden i form af noget output. Derfor har gls{il} flere muligheder for at bruge enkelte bit, fx så har de fleste hukommelses områder udvidelser til adresserne, der giver direkte adgang til bitsne. 

%\paragraph{Hukommelses områder}
En anden grund læggende forskel mellem Assembly og \gls{il} er abstraktionen af hukommelse. I Assembly er der kun en hukommelse der bliver tilgået med adresser. Dette giver muligheder for pointere der kan pege til både værdier i stacken og heapen.

I \gls{plc}'er er det meget mere opdelt i hukommelsesområder som alle bliver refereret til med et prefix til adressen, fx {\ttfamily W402}, hvor {\ttfamily W} er hukommelses området og {\ttfamily 402} er adressen på værdien. Dette giver bedre overblik over hvad type hukommelse man tilgår tilgengæld findes pointere kun i én af hukommelsesområderne. Det betyder at \enquote*{call by reference} er upraktisk hvis man vil have information liggende på andre områder.

For at udnytte hukommelsen på \gls{plc}'en bedre bruger PLC++ data hukommelses området ({\ttfamily D}) til data så som variabler og array, og Working hukommelses område ({\ttfamily W}) til en stack data struktur. Den eneste ulempe ved dette er at for at bruge pointere bliver programmet nød til at flytte værdien over til {\ttfamily D}-området før det fungere. Dette kan ses i eksemplet på arrays i tabel \ref{tab:codegenArray}.