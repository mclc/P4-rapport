%\subsubsection{Baggrund}
Til at generere \gls{il}-koden blev der udviklet endnu en visitor. Denne vistors primære opgaver er at skrive \gls{il}-kode til en destinationsfil, som udfører samme opgave som beskrevet i kildekoden. Da \gls{il} minder om Assembly i syntaksen og tilgængelige instruktioner kan vi bruge mange teknikker og teorier fra andre compilere, der compilere til det sprog. Ud over de små syntaktiske forskelligheder så er gls{il} fokuseret på at værdierne skal kunne repræsenteres i den virkelige verden i form af noget output. Derfor har \gls{il} flere muligheder for at bruge enkelte bit, fx så har de fleste hukommelses områder udvidelser til adresserne, der giver direkte adgang til bitsne. \\

%\paragraph{Hukommelses områder}
\noindent En anden grund læggende forskel mellem Assembly og \gls{il} er abstraktionen af hukommelse. I Assembly er der kun en hukommelse der bliver tilgået med adresser. Dette giver muligheder for pointere der kan pege til både værdier i stacken og heapen.

\noindent I \gls{plc}'er er det meget mere opdelt i hukommelsesområder som alle bliver refereret til med et prefix til adressen, fx {\ttfamily W402}, hvor {\ttfamily W} er hukommelses området og {\ttfamily 402} er adressen på værdien. Dette giver bedre overblik over hvad type hukommelse man tilgår tilgengæld findes pointere kun i én af hukommelsesområderne. Det betyder at \enquote*{call by reference} er upraktisk hvis man vil have information liggende på andre områder.\\

\noindent For at udnytte hukommelsen på \gls{plc}'en bedre bruger PLC++ datahukommelsesområdet ({\ttfamily D}) til data så som variabler og array, og Working-hukommelsesområde ({\ttfamily W}) til en stack datastruktur. Den eneste ulempe ved dette er at for at bruge pointere bliver programmet nødt til at flytte værdien over til {\ttfamily D}-området før det fungerer. Dette kan ses i eksemplet på arrays i tabel \ref{tab:codegenArray}. Årsagen til at {\ttfamily W} bruges til stack, fremfor {\ttfamily D}, er at {\ttfamily W} er meget hurtigere at tilgå på \gls{plc}'en. Dette skyldes at {\ttfamily D} er et persistent hukommelsesområde, hvilket typisk er langsommere end et ram-lignende område.