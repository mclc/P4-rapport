\subsection{Contextual Analysis}\wip
    Den kontekstuelle analyse af et givent program består af to dele; scope checking og type checking, og resultere i fejlrapporter der fortæller om type inkonsistensitet, og et \gls{ast} som er blevet \enquote*{dekoreret} med værdier der fortæller forskellige ting om noden, fx hvad type noden er, hvad variable der er referere til fra symbol tabellen og ligende. % Til dette bruges symbol tabellen i høj grad da den kan fortælle om hvad type bruger defineret variabler og funktioner er.
    
    Metoden til at gøre det er ved at iterere gennem \gls{ast}'et som blev gjort i syntax analyse afsnittet \ref{ssec:syntaxanalysis}. Der blev brugt et visitor mønster til at iterere gennem et \gls{ast}, det er så her double dispatch idéen som mønsteret løser kommer tilgode, for nu kan man meget let tilføje en ny handling der skal ske under interationen ved at tilføje en ny implementation af visitor interfacet.
    
\subsubsection{Type Checking}
    
    Type checking er øvelsen hvor man kontrollere at man ikke prøver at udføre operation der ikke er lovlige ifølge grammatikken. I mange programmerings sprog kan man fx ikke gange strings med integers i de fleste programmerings sprog. Dette er en ren kontekstuel del af grammatikken og er derfor ikke en del af \gls{cfg}.
    
    Måden at gøre dette på er ved at visitoren besøger noderne i \gls{ast}'et depth first, hvor den samler information om en nodes eventuelle børn som den så bruger til at verificere at den forventede type stemmer overens med den aktuelle type. Dette kan ses i figur \ref{fig:typecheck}.
    
    \tikzfigure{Figurer/TikZ/TypeChecking.tex}{Et eksempel på kontrol af typer for udtrykket: bool flag = 1 <= f}{typecheck}
    
    Fra figuren kan vi se hvordan at et declaration med en initializations værdi bliver udført bliver type checket. Først findes den forventet type som kommer fra erklæringen af variablen \enquote*{flag}. Bagefter finder vi den aktuelle type assignmentet ved at finde resultatet af udtrykket, som i dette tilfælde er et binær operator, som sammenligner to tal; en integer og en float. Denne kompiler køre under generaliserings princippet, hvilket vil sige at hvis tilfælde som dette opstår, vil den type der er mindst blive implicit omformet til den anden type, som set i figuren under BinaryOperation's noden. I noden bliver resultatet så evalueret til at være \enquote*{bool} som returneres til assignment noden som den aktuelle type.
    
\subsubsection{Scope Checking}

    Et scope er en grupperet mængde kode som kan 
    
    \paragraph{Dynamic scope} noget klogt er skrevet her omkring scopes
    
    \paragraph{Static scope} noget klogt er skrevet her omkring scopes

   % Det vil sige at en variable der er defineret i et scope bør være tilgængelig fra under scopes, men ikke de større scopes. Dette er selfølgeligt afhængigt af designet af sproget.
    
    \tikzfigure{Figurer/TikZ/SymbolTable.tex}{Symbol tabeller som de fungere i compileren til \sprognavn}{symtab}
    
    %\tikzfigure{Figurer/TikZ/SableCC_NFA.tex}{}{}
    
\subsubsection{Symbol tabel}
    Når man udvikler en kompiler til et sprog med brugerdefineret variabler, er det en fordel at kompileren har et fast sted hvor den kan slå op for at finde ud af om variablen er defineret, hvad type den har, og eventuelt hvad scope den er defineret i. Dette er en symbol tabel, som set i tabel \ref{tab:symboltabel}.
    
\AnsiC{Kode/SymTableExample.c}{Program brugt til at danne følgende symbol tabel}{tableprog}

    \begin{table}[h]
    \centering\footnotesize
    \begin{tabular}{l l l}
    Id & Type & Scope \\\midrule
    foo & function, double & global\\
    count & integer & function parameter\\
    sum & double & local block\\
    i & integer & for-loop statement
    \end{tabular}
    \caption{Eksempel på en symbol tabel for et simpelt program.}
    \label{tab:symboltabel}
    \end{table}
    
    I denne tabel kan man se hvordan man kan finde viden om 
    
    Tabellen bliver hovedsageligt brugt i forbindelse med type checking af et \gls{ast}, men bliver også brugt i andre faser af kompileringsprocessen til at skrive, læse og dele information til/fra tabellen omkring variabler, funktioner og andet. For eksempel kan man vælge at udvide et \gls{ast} med information der bliver brugt til optimering af objekt koden.