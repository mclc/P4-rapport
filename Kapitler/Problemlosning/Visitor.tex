\section{Visitor Mønsteret}\label{sec:visitor}

\cfix{Jeg antager at vi allerede er klar over at vi vil lave en kompiler og at vi har redegjordt lidt for hvordan vi vil bruge abstract systax trees til at gøre dette. Derfor forslår jeg at dette afsnit bliver rykket ned under Compilere-afsnittet}
\mfix{Dette var en diskussion vi havde til et gruppemøde. Men lad os se på det når afsnittet er færdigt.}

Når man laver et AST\fn{AST}{Abstract Syntax Tree} under kompileringen af noget kilde kode, så vil treet have mange forskellige noder som skal opføre sig forskelligt. Dette er almindeligt objekt oritenteret design, med en abstrakt super klasse der definere metoderne som sub klasserne så overskriver. Det AST vil vi så gerne kunne gå igennem af flere grunde, fx for at analysere koden eller generere objekt koden. 

Så det arbejde der bliver udført er afhænging af to ting; typen af noden der bliver udført og hvad type arbejde der er brug for (analyse, generering o.lign.). Dette kan gøres ved at kalde forskellige metoder på noderne afhængig af type af arbejde der skal udføres, det betyder bare at koden bliver spredt hvilket gør vedligeholdelse af programmet besværligt.

\tikzfigure{Figurer/TikZ/VisitorPattern.tex}{Den gennerelle model af Visitor-mønstret. \cite{Oliveira_2008}}{visitor}

For at imødekomme denne situration er visitor mønsteret, som set på figur \ref{fig:visitor}, blevet udviklet. Mønsteret forsøger at samle koden for forskellige typer af arbejde i hver sin klasse afhængig af hvad type arbejde der skal udføres i figuren er dette IVisitor interfacet, hvor ConcreteVisitor klassen er en type af arbejde. Ud over dette så bliver elementerne, eller i tilfældet med en kompiler noderne, ansvarlige for at kalde den korrekte metode hos visitoren.

Ulemperne ved at bruge visitor mønsteret er at hvis man tilføjer en ny type element skal man ændre det i IVisitor interfacet, og som følge af det i alle visitor klasser, så derfor kan det være en fordel at implementere mønsteret senere i udviklings processen af programmet.

\subsection{Reflektive Visitor}\label{ssec:refvisitor}

Reflektive visitor er en metode hvor mange at visitor mønsterets svagheder bliver håndteret. Måden dette bliver gjort på er ved at i stedet for at hver element er ansvarlig for at kalde den bedste metode for sig selv, kalder alle elementer samme metode på visitoren, som så i stedet er ansvarlig for at kalde den bedste metode. Fordelene ved at gøre det sådan er at visitoren kun behøver at have data omkring de relevante noder og kan lade andre gå til en standard metode, dermed behøver alle visitors ikke at implementere en ny metode hvergang en ny type node bliver implementeret.