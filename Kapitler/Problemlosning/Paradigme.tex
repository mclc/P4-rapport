%Claus - 18/02/2015
%Gade - 24-03-15
\section{Programmeringsparadigmer}\label{sec:paradigmer}\label{ssec:hovedparadigmer}

I takt med at der er blevet udviklet flere og flere programmeringssprog – hvor der i dag findes hundredevis af forskellige sprog, har man for simplicitetens skyld, valgt at opdele sprogene i paradigmer og generationer. Programmeringsparadigmer opdeles typisk i fire overordnede kategorier; det imperative, funktionsorienterede, objektorienterede og det logiskbaserede paradigme. Hvoraf den typiske inddeling af sprogene i generationer vil kategoriseres mellem 1-5 generationssprog. Nedenstående afsnit vil afdække de relevante paradigmer. Det logiskbaserede bliver gennemgået, da de fleste programmeringsopgaver til \gls{plc}’er bliver kodet i netop dette paradigme (afsnit \ref{subsec:plcsoftware}). Det imperative og objektorienterede paradigme bliver undersøgt, for at udforske potentielle løsninger, på den opstillede problemformulering (afsnit \ref{sec:problemformulering}). Det funktionelle paradigme vil blive undladt, fordi paradigmet er irrelevant i en udarbejdet løsning, da det funktionelle paradigme er centreret omkring algoritmer og at det er stadieløst. PLC'er arbejder nærmest udenlukkende med stadier i forhold til input og ouput porte. Algoritmerne der typisk bliver benyttet til PLC'er er desuden ikke af en sådan kompleksibilitet at det funktionelle paradigme giver mening. Det funktionelle paradigme er derudover praktisk til multikerne processorer, hvilket heller ikke er aktuelt for PLC'er. \cite{functprog}

\tocless \subsection{Logisk}
I takt med at software blev dyrere at producere, relativt til hardware, opstod der et behov for en logisk fremgang, for at nedsætte den tid programmørene skulle bruge på at fortælle computeren hvordan den skal løse en opgave, men i stedet hvad den skulle løse. Til dette blev logisk programmering benyttet, der går ud på at man opstiller nogle regler, som compileren finder ud af hvordan og hvornår skal benyttes. Styrkerne ved dette paradigme er at den færdige kildekode er en type logisk definition og kan derfor lettere læses og vedligeholdes \cite[kapitel 16]{Sebesta_2013}. Dette paradigme benytter de fleste \gls{plc}'er idag, hvor \gls{il} kan kategoriseres som et 2. generationssprog.

\tocless \subsection{Imperativt}
\label{sec:c_is_easy2}
Da man begyndte at udvikle generelle programmeringssprog der skulle gøre det lettere at formulere programmer, havde effektiviteten af programmet højeste prioritet. Derfor var det naturligt at man byggede ovenpå den grundlæggende arkitektur der stadig findes i moderne computere; von Neumann arkitekturen. Dette gav grundlag for mange af de imperative sprog der i dag findes, disse sprog er en abstraktion over arkitekturen og giver programmøren kontrol over tilpasning og optimering af enkelte programdele \cite[38-39]{Sebesta_2013}. I de imperative sprog er det variabler, der holder styr på stadiet programmet er i, og løkker der er de centrale funktioner \cite{Sebesta_2013}. Flere anbefaler C (Imperativt) sprog som et godt begyndersprog, for folk uden større programmeringserfaring, og da målgruppen er industritekniker ville dette paradigme være passende \cite{c_is_easy}.

\tocless \subsection{Objektorienteret}
Objektorienteret programmering blev udviklet da det imperative paradigme viste sig at blive for uoverskueligt til større programmer med meget data. Sprog i dette paradigme abstraherer fra det imperative paradigme ved at indkapsle funktioner og variabler i klasser. På den måde kan man via klasser modellere objekter i virkeligheden med data og metoder. En klasse er på den måde et opskrift hvoraf objekter kan laves/instantieres. I problemanalysen (afsnit \ref{sec:plc}) viste CODESYS, som benytter sig af det objektorienterede paradigme til \gls{plc}-programmering, at det forøger overblikket, men samtidig at \gls{oop} er for omstændigt ved små og mellemstore projekter.

%Ligeledes indeholder det ikke features som er mindre relevante og primært kun bidrager til øget kompleksitet. Features som at kunne modellere objekter i virkeligheden, som ved objektorienteret programmering. Det er også værd at nævne, at det logiske paradigme ikke løser problemet med abstraktionsniveauer og derfor ikke er taget i betragtning som en løsning.,

%Et paradigme er på Oxford Onlinedictionary beskrevet som et typisk eksempel eller et mønster \cite{Oxford_????}. I programmeringssammenhæng forstås det som at være de overordnede principper for et programmeringssprog. Der findes i dag over 30 forskellige paradigmer, men mange af dem er kun forskellige på meget få punkter \cite{Roy_2009}. Derfor vil kun tre af hovedparadigmerne bliver forklaret: Logisk, imperitivt og objektorienteret.\sfix{Hvorfor er funktionelt ikke inkluderet - De 4 hovedparadigmer anyone?}