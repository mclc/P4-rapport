%Claus - 18/02/2015
%Gade - 24-03-15
\section{Programmeringsparadigmer}\label{sec:paradigmer}\label{ssec:hovedparadigmer}

I takt med at der er blevet udviklet flere og flere programmeringssprog – hvor der i dag findes hundredevis af forskellige sprog, har man for simplicitetens skyld, valgt at opdele sprogene i paradigmer og generationer. Programmeringsparadigmer opdeles typisk i fire overordnede kategorier; det imperative, funktionsorienterede, objektorienterede og det logiskbaserede paradigme. Hvoraf den typiske inddeling af sprogene i generationer vil kategoriseres mellem 1-5 generationssprog. Nedenstående afsnit vil afdække de relevante paradigmer. Det logiskbaserede bliver gennemgået, da de fleste programmeringsopgaver til \gls{plc}’er bliver kodet i netop dette paradigme (se afsnit refxx). Det imperative og objektorienterede paradigme bliver undersøgt, for at udforske potentielle løsninger, på den opstillede problemformulering (se afsnit refxx). Det funktionelle paradigme vil blive undladt fordi paradigmet er irrelevant for den færdige løsning.

\subsubsubsection{Logiskbaseret}
I takt med at software blev dyrere at producere, relativt til hardware, opstod der et behov for en logisk fremgang, for at nedsætte den tid programmørene skulle bruge på at fortælle computeren hvordan den skal løse en opgave, men i stedet hvad den skulle løse. Til dette blev logisk programmering benyttet, der går ud på at man opstiller nogle regler, som compileren finder ud af hvordan og hvornår skal benyttes. Styrkerne ved dette paradigme er at den færdige kildekode er en type logisk definition og kan derfor lettere læses og vedligeholdes \cite[kapitel 16]{Sebesta_2013}. Dette paradigme benytter de fleste \gls{plc}'er idag, hvor \gls{il} kan kategoriseres som et 2. generationssprog.

\subsubsubsection{Imperativt}
Da man begyndte at udvikle generelle programmeringssprog der skulle gøre det lettere at formulere programmer, havde effektiviteten af programmet højeste prioritet. Derfor var det naturligt at man byggede ovenpå den grundlæggende arkitektur der stadig findes i moderne computere; von Neumann arkitekturen. Dette gav grundlag for mange af de imperative sprog der i dag findes, disse sprog er en abstraktion over arkitekturen og giver programmøren kontrol over tilpasning og optimering af enkelte programdele \cite[38-39]{Sebesta_2013}. I de imperative sprog er det variabler, der holder styr på stadiet programmet er i, og løkker der er de centrale funktioner \cite{Sebesta_2013}. Flere anbefaler C (Imperativt) sprog som et godt begyndersprog, for folk uden større programmeringserfaring, og da målgruppen er industritekniker ville dette paradigme være passende.

\subsubsubsection{Objektorienteret}
Objektorienteret programmering blev udviklet da det imperative paradigme viste sig at blive for uoverskueligt til større programmer med meget data. Sprog i dette paradigme abstraherer fra det imperative paradigme ved at indkapsle funktioner og variabler i klasser. På den måde kan man via klasser modellere objekter i virkeligheden med data og metoder. En klasse er på den måde et opskrift hvoraf objekter kan laves/instantieres. I problemanalysen (se afsnit refxx) viste CODESYS, som benytter sig af det objektorienterede paradigme til \gls{plc}-programmering, at det forøger overblikket, men samtidig at \gls{oop} er for omstændigt ved små og mellemstore projekter.

\subsection{Valg af paradigme}\label{ssec:paradigmevalg}
Ved \gls{plc} programmering er størstedelen af formålet at styre mekaniske anlæg og kommunikere med andre enheder som \gls{hmi} paneler via digitalt \gls{io} (se afsnit refxx). Disse programmeringsopgaver er fortrinsvis simple i kontekst, da \gls{io} i forvejen er forholdsvis simple. Der er derfor ikke behov for at kunne modellere komplekse objekter i virkeligheden. Dog skal det nævnes, at selv om \gls{io} er simple opgaver i kontekst, skal det være muligt at kunne opdele programmet i flere abstraktioner, da et anlæg kan være - og ofte er - opbygget i flere sektioner/dele. \\

\noindent Ud fra disse betragtninger er det blevet vurderet, at det imperative paradigme passer bedst. Det løser problemet med at skulle kunne opdele anlæggets dele i forskellige abstraktionsniveauer. Ligeledes indeholder det ikke features som er mindre relevante og primært kun bidrager til øget kompleksitet. Features som at kunne modellere objekter i virkeligheden, som ved objektorienteret programmering. Det er også værd at nævne, at det logiske paradigme ikke løser problemet med abstraktionsniveauer og derfor ikke er taget i betragtning som en løsning.


%Et paradigme er på Oxford Onlinedictionary beskrevet som et typisk eksempel eller et mønster \cite{Oxford_????}. I programmeringssammenhæng forstås det som at være de overordnede principper for et programmeringssprog. Der findes i dag over 30 forskellige paradigmer, men mange af dem er kun forskellige på meget få punkter \cite{Roy_2009}. Derfor vil kun tre af hovedparadigmerne bliver forklaret: Logisk, imperitivt og objektorienteret.\sfix{Hvorfor er funktionelt ikke inkluderet - De 4 hovedparadigmer anyone?}