\section{Kravspecifikation}
Kravspecifikationen vil på baggrund af den opstillede problemformulering, benytte \gls{moscow}-analysen til at afdække hvilke krav der er til det kommende sprog (PLC++). Indledningsvist vil der blive fulgt op på det forrige afsnit, programmeringsparadigmer, hvor valget heraf vil blive redegjort. Efterfølgende vil kriterierne, såsom høj \textit{skrivbarhed} og \textit{pålideligt}, blive uddybet i kriterier-afsnittet. Kravspecifikationen har til formål at klarlægge, og definere specifikke retningslinjer til det kommende sprog.

\subsection{Valg af paradigme}\label{ssec:paradigmevalg}
Ved \gls{plc}-programmering er det primære formål at styre mekaniske anlæg og kommunikere med andre komponenter. Disse programmeringsopgaver er fortrinsvis simple, med få operationer, og der vil af disse årsager, ikke være behov for at kunne modellere programmet i klasser og objekter. Dog skal det nævnes, at selv om \gls{io} er simple opgaver i kontekst, skal det være muligt at kunne opdele programmet i flere abstraktioner, da et anlæg kan være - og ofte er - opbygget i flere sektioner/dele. Det primære formål, er at konstruere et programmeringssprog som vil forøge \textit{læsbarhed} og dermed også give et større overblikket i mellemstore projekter. \\

\noindent Ud fra disse betragtninger er det blevet vurderet, at det imperative paradigme passer bedst. Det løser problemet med at skulle kunne opdele anlæggets dele i forskellige abstraktionsniveauer - ved at understøtte programmeringsfunktionaliteter som funktioner og structs. Samtidig er eksekveringshastigheden hurtig i det imperative paradigme, modsat det objektorienterede (se afsnit refxx (mangler)), hvilket er en essentiel faktor i \gls{plc}'er. \\

\noindent Det blev tidligere nævnt (se afsnit refxx), at mange syntes C er et godt begyndersprog, blandt andet grundet den lave \textit{indlæringskurve}. Det ville derfor være naturligt at det udviklende sprog bliver inspireret af C’s syntaks. 

\subsection{MoSCoW}
\gls{moscow}-analysen har til formål at skitserer hvilke krav der er til programmeringssproget. Tabel \ref{tab:moscow} vil således opstille funktionerne efter prioriteringer; hvor den højeste prioritet vil være placeret i Must-Have, og laveste prioritet i Want-To-Have. Efterfølgende vil funktionerne blive gennemgået, hvor yderligere kommentarer til prioriteringen vil blive forklaret.

%
% DENNE TABEL ER LIDT FOR STOR, MEN ELLERS KAN DET IKKE STÅ PÆNT, OG MAN SER DET IKKE I RAPPORTEN.....
%
\begin{table}[H]
\centering
%\rowcolors{2}{blue!10}{white}
\begin{tabular}{l|l|l|l}
\toprule
\textbf{Must have} & \textbf{Should have} & \textbf{Could have} & \textbf{Want to have} \\ \midrule
Kontrolstruktur & Increment/Decrement & Const & Betingede udtryk   \\ 
Datatyper & Compound assignments & & \\ 
Port & Information hiding & &	   \\ 
Structs	&  &  &		   \\ 
Funktioner &  &  & 		   \\ 
Kommentarer &  &  & 		   \\ 
Arrays &  &  & 	   \\ 
Operatorer &  &  & 		   \\ \bottomrule
 
%if & for & do-While & Betingede udtryk   \\ \hline
%int & decrement & const & unsigned int  \\ \hline

% structs & increment & Optimizer &    \\ \hline
% Expressions & Compound assignments &  &   \\ \hline
% while & switch &  &    \\ \hline
 
% char & string &  & unsigned char  \\ \hline
% long &  &  & unsigned long  \\ \hline
% float &  &  &   \\ \hline
% double &  &  &   \\ \hline
% timer &  &  &   \\ \hline
% port &  &  &   \\ \hline
% bool &  &  &   \\ \hline
% funktioner &  &  &    \\ \hline
% array &  &  &    \\ \hline
% Kommentarer &  &  &   \\ \hline
% Operatorere &  &  &   \\ \hline

% Assignments &  &  &    \\ \hline
% Declaration  &  &  &   \\ \hline
\end{tabular}
\caption{MoSCoW-tabel}
\label{tab:moscow}
\end{table}

\noindent Uddybende forklaringer til ovenstående tabel \ref{tab:moscow}, vil blive forklaret i nedenstående afsnit.

\subsubsubsection{Kontrolstruktur}
Kontrolstruktur er placeret som ét must-have da kontrolstrukturer er en helt elementær del af et programmeringssprog. At kunne opsætte betingelser for hvornår en given handling skal eksekveres er essentielt – især i forbindelse med programmering af \gls{plc}’er, hvor inputs fra sensorer og temperaturfølere ofte skal aktivere en udgang. 
Af denne årsag vælges der at implementere \textit{if} og \textit{while}, med henblik på senere hen at implementere \textit{for}, \textit{do-while} samt \textit{switch}. Dette er grundet at man med \textit{if} og \textit{while} kan konstruere de andre, men ikke omvendt. Dog kan det være besværligt og ineffektivt at konstruere en switch vha. if, da switch-kontrolstrukturen kan \textit{falde igennem} til næste betingelse.

\textit{do-while} som er en \textit{iterative kontrolstruktur}, bliver dog kun implementeret hvis der er tid tilovers, og bliver derfor nedprioriteret til Could-Have. Dette skyldes naturligvis, at man vha. af For og While-løkker kan opnå tilsvarende funktionalitet som \text{do-while}.

\subsubsubsection{Datatyper og Port}
Datatyper skal forstås som de basale datatyper (såsom \textit{int}, \textit{float} …), som sproget skal indeholde. PLC++'s typesystem er meget sammenligning med C med et par få tilføjelser, disse tilføjelser er \textit{timer}, \textit{port} samt \textit{bool} (se afsnit \ref{sec:forskelfrac}).
Timer kan implementeres som en typedefineret \textit{struct}, hvorved programmøren får mulighed for at benytte en række brugerdefinere compiler genererede metoder, såsom \textit{start}, \textit{stop} og \textit{reset} timer. Timers funktionalitet er dermed at give programmøren mulighed for at kunne starte/stoppe en timer – som er ofte anvendt i \gls{plc} – der sætter et output når den definerede tid timeren er sat til, udløber.
\textit{Port} er en datatype, som enten kan være defineret som \textit{'I'} (Input), \textit{'Q'} (Output), \textit{'M'} (Intern memory), \textit{'AI'} (Analog input), \textit{'AQ'} (Analog output) og som indeholder et \# efterfølgende. Denne datatype kan bruges til at skifte en port til en anden på kørselstidspunktet. Dette er eksempelvis praktisk i forhold til funktioner, da man så kan tage en port som input parameter.
\textit{Strings} er essentielt for at kunne kommunikere med \gls{hmi}-komponenter, såsom \gls{plc}-monitors, og er derfor ligeledes høj prioritet. 

\subsubsubsection{Structs} Structs en måde at gruppere data således man har en type der kan indeholde flere og forskellige typer. Derudover har hver variabel i en struct et navn, som derfor hjælper for abstraktionen. Eksempelvis skal et punkt have både en x og y kordinat. En funktion vil dermed kunne tage et punkt som input parameter, i stedet for at skulle overføre de enkelte variabler. Structs bliver dermed en meget stor fordel ved behov for mange variabler.

For at øge abstraktionen yderligere kan man implementere muligheden for funktioner inde i structs. Dette giver mulighed for at stille en række hjælpemetoder til rådighed for den konkrete struct. Dermed slippes for funktioner med forskellige prefixes for at forhindre at funktionsnavnene konflikter.

En måde man kan øge abstraktions niveauet endnu mere er vha. information hiding således det er muligt at skjule konkrete implementationsdeltaljer for resten af koden. Derudover kan nedarvning og polyformeri også være godt for genbrugeligheden i kode.

Disse egenskaber definere desuden det objektorienterede paradigme, som derfor tilbyder endnu højere abstraktion end den helt simple struct der kun kan indeholde felter. Dog kaldes det objekter i det objektorienterede paradigme. Derudover er der også forskel på hukommelseshåndteringen mellem objekter og structs.

Dog er der blevet valgt ikke at fokusere på det objektorienterede paradigme pga. hastigheden og begrænsninger på PLC'en som er nærmere belyst i afsnit \ref{sec:plcprob}

Information hiding kan dog være praktisk for \gls{plc} programmering, da det gør det muligt at stille et public api til rådighed for structs, som skjuler konkrete implementationsdeltalier. Information hiding kan desuden laves som et compiler step og bruger derfor ikke yderligere ressourcer. Information hideing bliver derfor placeret i moscow analysen under should have.

\subsubsubsection{Arrays}
Arrays er en let og overskuelig måde at opbevare et dataset, og er derfor på listen over must have. Arrays giver muligheden for at indeksere hvert felt med et tal, og giver dermed fleksibilitet og overskuelighed som kendt fra \textit{C}.

Men for at øge abstraktions niveauet og dermed gøre det mere overskueligt for programmøren ville en implementation af denne funktion være ideel.

\subsubsubsection{Const}
Const giver mulighed for at bibeholde dataene i den pågældende variablel, og derved giver den en form for skrivebeskyttelse, således at man ikke kan overskrive denne.

Funktionen er placeret under could have, da den ikke er essentiel for at programmet kan køre, eller gør det lettere for programmøren. 
Dog kan den i flere tilfælde være rar at benytte, og tilføjes derfor som en mulig implementation.

\subsubsubsection{Funktioner}
Funktioner er med til at opdele programmet i flere dele, dette gør det mere læsbart og isolerer koden i små scoops.

Dette er med til at øge abstraktionsniveauet og giver mulighed for at genbruge kode i andre handlinger.
Funktioner er en af byggestenene for programmeringssproget og er derved kategoriseret som must have.

\subsubsubsection{Betingede udtryk}
Betingede udtryk er et udtryk der giver mulighed for at først have en betingelse og så en expression hvis betingelsen er sand eller en anden hvis betingelsen er falsk.

\subsubsubsection{Generelt} 
Generelt er der integreret flere funktioner som hovedsageligt er mere globale og kan bruges generelt i flere sammenhænge. En af disse funktioner er kommentarer som er essentielt for et programmeringssprog at indeholde, og derfor er funktionen placeret under Must have. Kommentarer giver mulighed for at strukturere kode, og skriv en kommentar til det, hvilket kan gøre det mere overskueligt i store såvel som små programmer.

Udover kommentarer er der implementeret flere operatorer, som gør det muligt at lave matematiske operationer, dette er nemt at implementere og en basal funktion som skal være til stede ved \gls{plc} programmering.

Til sidst skal det være muligt at lave assignments og declarations som er essentielt for at kunne tildele variabler eller udtryk en værdi.

\subsection{Forskel fra C}
\label{sec:forskelfrac}
I projektet er der blevet taget udgangspunkt i C, hvor man har valgt at tage sin egen erfaring med C kombineret med andres, og tage det bedste fra sproget samt tilføje eventuelle mangler eller ønsker.
Nogle af disse tilføjelser er blandt andet den boolske datatype, som giver et højere abstraktion, hvilket gør det  lettere for programmøren at associere det med virkelige hændelser.

Hertil giver det anledning til at programmøren ikke laver lige så mange fejl, baseret på at datatypen \textit{boolean} kun accepterer true/false, hvorimod en \textit{int} som agerer som en \textit{boolean} i C kan acceptere flere værdier.

Ligeledes er det valgt ikke at implementere pointeraritmetik af den grund, at det skaber potentielle fejlkilder, som kan være en hindring for selv den øvede programmør. Hertil er det tænkt at det skal være et effektivt programmeringssprog, hvor programmøren ikke eksplicit skal erklære hvad han/hun vil.\sfix{Så er vi vel ovre i det logiske paradigme}

\subsection{Kriterier}
Dette afsnit resulterer i en række kriterier som er prioriteret efter behov, som er med til at skabe et brugbart og yderst velegnet sprog til målgruppen uden væsentlige svagheder. Omtalte behov kan delvist udledes fra problemanalysen (Afsnit \ref{sec:problemanalyse}), såvel som \gls{moscow}-analysen.
Følgende sektioner udspecificerer kriterierne individuelt og deres prioritet i en samlet tabel.\\

\subsubsection*{Readability} Readability er kriteriet som omhandler hvor læsbart programmet er, samt om programmøren kan se handlingen og derved forstå hvad der programmet gør.

Dette er vigtigt for at en ny programmør hurtigt kan sætte sig ind i hvordan programmet fungerer. Dermed spares penge, da programmøren skal bruge mindre tid på at finde ud af hvad koden gør. 

Readability er blevet placeret i kategorien "Vigtig" på grund af det "trade-off" som finder sted, når man vælger at øge writeability´en.
Dette trade-off sker, ved at man øger writeabilityen som gør at koden er lettere at skrive, hvilket ikke altid gør det lettere at læse, og omvendt bliver det ikke lettere at skrive hvis det skal være lettere at skrive, og dermed kan man i de fleste tilfælde ikke opnå begge dele.
\\
Dette vil sige at et for loop i sproget COBOL er mere læsbart i forhold til C\#, dette kan ses på kodeeksempel \ref{code:ekscobol}

\Cobol{Kode/Readability-cobol.cbl}{For-loop}{ekscobol}

\noindent Man ser at opbygningen af koden, ligner meget en almindelig sætning, hvilket er meget let at læse. Derimod hvis man ser på C\# kodeeksempel \ref{code:ekscsharp} kan man se at opbygningen af opbygningen af sætningen indeholder parenteser, akkolade og semikolon, hvilket gør det besværligt at læse for programmører.

\CSharp{Kode/Readability-csharp.cs}{For-loop}{ekscsharp}


\subsubsection*{Writeability} Writeability er et kriterie for hvor let det er at skrive koden. Dermed har writability meget af gøre med hvilken syntaks der benyttes. Dette er med til at sikre, at programmøren hurtigt og effektivt kan skrive koden.

Eksempelvis indeholder nogle sprog begin og end blokke, hvor andre bruger et enkelt tegn til at repræsentere det samme, herunder typisk et scope. Dermed er det meget hurtigere at skrive kode i sproget der kun kræver et tegn hver gang programmøren ønsker et nyt scope.

Writability giver dog typisk et trade-off i forhold til Readability, som forklaret under Readability.\\

\subsubsection*{Adaptability} Adaptability er muligheden for at tilpasse koden til andre enheder, hvor det i \gls{plc} verdenen, ville betyde at man ville kunne bruge programmeringssproget, på flere forskellige enheder selvom det er forskellige producenter. Adaptability er valgt at kategorisere som vigtigt, da det ville være lettere for en automatiktekniker at kunne lærer et sprog, og kunne bruge det til alle \gls{plc} enheder.

\subsubsection*{Learnability} Learnability er hvor let programmeringssproget er at lære, og hvor let det er at benytte det.

Herunder er Learnability hvor nemt programmøren har ved at indlærer nye funktioner, ud fra dokumentationen, da programmøren umuligt kan huske alle funktioner i et stort sprog, og derved skal kunne indlære det på ny, ved at kigge på et dataark. \\
Learnability er placeret under mindre vigtigt, da sproget er prioriteret til automatikteknikere, som har gennemgået et grundkursus, hvilket er med til at sikre at den kommende programmør bliver sat ordenligt ind i sproget. Hermed er det valgt at nedprioritere sprogets learnability, således der kan implementeres flere funktioner, som giver en rig mulighed for udnyttelse af hele \gls{plc}´en.\\\sfix{Jeg ville prioritere anderledes - det er netop vigtigt så vi kan få anvendelsen af PLC++ højere op}

\subsubsection*{Orthogonality} Orthogonality er muligheden for at kunne kombinere forskellige dele af sproget til mere avancerede konstruktioner. Særregler gør sproget mindre ortogonalt. Hvis det er muligt at benytte alle mulige kombinationer af sprogets dele er sproget altså fuldstændigt ortogonalt. Dermed kan orthogonality have indflydelse på både writability idet det bliver lettere at lave avancerede konstruktioner, readability da konstruktionerne kan blive meget komplekse og dermed mindre læsbare. Da skrivbarhed også er meget vigtigt er orthogonality ligeledes blevet lagt under vigtigt sammen med readability. Orthogonality er dog ikke målet i sig selv, og det er derfor vigtigere med højere readability.\\\sfix{Tjek op på forklaringen - prioritet?}

\subsubsection*{Reliability} Reliability er hvordan koden håndterer fejl, og hvor pålideligt koden der kan skrives med programmeringssproget er. Dette er med til at sikre at maskiner som kører med denne kode, har en form for fejlhåndtering, som giver programmøren mulighed for at kunne bearbejde fejlen, og derved endda kunne fortsætte programmet, selvom der opstod en fejl.

Dette er en vigtig parameter i løsningen, da det skal kører på en \gls{plc} hvor driftsikkerhed er en af top prioriteterne. Dog er fejlhåndtering vha. exceptions ineffektivt og der afgrænses i første omgang derfor for fra det.\\\sfix{Argument igen for imperativt - men også argument for exception handling}


\begin{table}[H]
\centering
\rowcolors{2}{black!5}{white}
\begin{tabular}{l c c c c}
\toprule
\textbf{Kriterium} & \textbf{Meget vigtigt} & \textbf{Vigtigt} & \textbf{Mindre vigtigt}  \\ \midrule
Readability        &   & X &       \\ 
Writeability       & X &   &       \\ 
Adaptability       &   & X &       \\ 
Learnability       &   &   & X     \\ 
Orthogonality      &   & X &       \\ 
Reliability        & X &   &       \\ \bottomrule
\end{tabular}
\caption{Endelige kriterier som løsningen skal opfylde}
\label{table:kriterier}
\end{table}



%Ud fra problemformuleringen er der blevet lagt vægt på en løsning der tilgodeser et højere abstraktionsniveau samt en højere effektivitet ved udvikling af programmer.