\section{Kravspecifikation}
Kravene til PLC++ tager udgangspunkt i C med en del ændringer. C bidrager til kravet om abstraktionsniveauet med dets mulighed for at benytte funktioner. Ligeledes har C datatypen \textit{struct} som kan imitere objekter i den virkelige verden.

De vigtigste krav til PLC++ vil blive gennemgået, forklaret og prioriteret i en MosCOW. Den fulde syntax specifikation kan findes i bilag \ref{bil:cfg}

\subsection{MoSCoW}
\gls{moscow}-analysen har til formål at belyse kravspecifikationens funktioner, samt opnåelse af disse.
Disse funktioner kan ved hjælpe af \gls{moscow}-analyse opstilles med prioritet, for hvert individuelle funktion.
Prioteringen for den individuelle funktion er nødvendig, i forhold til det tidsmæssige aspekt, og giver ydermere en arbejdsstruktur for implementationen af funktionen.

%
% DENNE TABEL ER LIDT FOR STOR, MEN ELLERS KAN DET IKKE STÅ PÆNT, OG MAN SER DET IKKE I RAPPORTEN.....
%
\begin{table}[H]
\centering
%\rowcolors{2}{blue!10}{white}
\begin{tabular}{l|l|l|l}
\toprule
\textbf{Must have} & \textbf{Should have} & \textbf{Could have} & \textbf{Want to have} \\ \midrule
Kontrolstruktur & Decrement & Const & Betinget udtryk   \\ 
Datatyper & Compound assignments & Unsigned datatyper  & \\ 
Structs & Increment &  &	   \\ 
Specielle Datatyper	&  &  &		   \\ 
Funktioner &  &  & 		   \\ 
Kommentarer &  &  & 		   \\ 
Arrays &  &  & 	   \\ 
Operatorere &  &  & 		   \\ \bottomrule
 
 %if & for & do-While & Betingede udtryk   \\ \hline
 %int & decrement & const & unsigned int  \\ \hline
 
 
% structs & increment & Optimizer &    \\ \hline
% Expressions & Compound assignments &  &   \\ \hline
% while & switch &  &    \\ \hline
 
% char & string &  & unsigned char  \\ \hline
% long &  &  & unsigned long  \\ \hline
% float &  &  &   \\ \hline
% double &  &  &   \\ \hline
% timer &  &  &   \\ \hline
% port &  &  &   \\ \hline
% bool &  &  &   \\ \hline
% funktioner &  &  &    \\ \hline
% array &  &  &    \\ \hline
% Kommentarer &  &  &   \\ \hline
% Operatorere &  &  &   \\ \hline

% Assignments &  &  &    \\ \hline
% Declaration  &  &  &   \\ \hline
\end{tabular}
\caption{MoSCoW-tabel}
\label{tab:moscow}
\end{table}

\noindent Som en forklaring på disse funktioner beskrives de i kategorier herunder.\\

\noindent\textbf{Structs}
Structs er en måde at gruppere data således man har en type der kan indeholde flere og forskellige typer. Derudover skal hver variabel i en struct have et navn, som derfor hjælper for abstraktionen. Eksempelvis skal et punkt have både en x og y kordinat. En funktion vil dermed kunne tage et punkt som input parameter, i stedet for at skulle overføre de enkelte variabler. Structs bliver dermed en meget stor fordel ved behov for mange variabler.

For at øge abstraktionen yderligere kan man implementere muligheden for funktioner inde i structs. Dette giver mulighed for at stille en række hjælpemetoder til rådighed for den konkrete struct. Dermed slippes for funktioner med forskellige prefixes for at forhindre at funktionsnavnene konflikter.

En måde man kan øge abstraktions niveauet yderligere er vha. information hiding således det er muligt at skjule konkrete implementationsdeltalier for resten af koden. Derudover kan nedarvning og polyformeri også være godt for genbrugeligheden i kode.

Disse egenskaber definere desuden det objektorienterede paradigme, som derfor tilbyder endnu højere abstraktion end den helt simple struct der kun kan indeholde felter. Dog kaldes det objekter i det objektorienterede paradigme. Derudover er der også forskel på hukommelseshåndteringen mellem objekter og structs.

\noindent\textbf{Arrays}
er en let og overskuelig måde at opbevarer et dataset, og er derfor på listen over Must have. Arrays giver muligheden for at indeksere hvert felt med et tal, og giver dermed fleksibilitet og overskuelighed som kendt fra \textit{C}.

Men for at øge abstraktions niveauet og dermed gøre det mere overskueligt for programmøren ville en implementation af denne funktion være ideel.\\

\noindent\textbf{Const}
giver mulighed for at bibeholde dataene i den pågældende variablel, og derved giver den en form for skrivebeskyttelse, således at man ikke kan overskrive denne.

Funktionen er placeret under could have, da den ikke er essentiel for at programmet kan kører, eller gør det lettere for programmøren. 
Dog kan den i flere tilfælde være rar at benytte, og tilføjes derfor som en mulig implementation.\\

\noindent\textbf{Datatyper og unsigned}
er integreret meget sammenligning med C med et par få tilføjelser, disse tilføjelser er timer, port, string samt bool.\\
Timer er en datatype, som kan indeholde en tid i form af \textit{hh:mm:ss} hvor værdien begynder på 00:00:00 og ender ved 23:59:59, denne timer er beregnet til at kunne udfører tidsbestemte handlinger i programmet.\\
Port er en datatype, som enten kan være defineret som \textit{'I'} (Input), \textit{'Q'} (Output), \textit{'M'} (Intern), \textit{'AI'} (Analog input), \textit{'AQ'} (Analog output) og som indeholder et \# efterfølgende. Denne integration er en nødvendighed, i forhold til at man skal kunne styrer portene på \gls{plc}´en, hvilket derfor giver anledning til en ny datatype.

String har man valgt at sætte, som et højrankeret funktionalitetskrav i \gls{moscow}-analysen, da dette giver mulighed for at let håndtering af strenge baseret på text, tal og karaktere. \mefix{Vend tilbage, når string er implementeret, og skriv hvordan}

Til sidst er \textit{boolean} implementeret, hvilket kan læses under afsnit \ref{sec:forskelfrac}\\
Unsigned er blevet nedprioriteret og derved placeret i could have, da denne funktionalitet ikke er yderst nødvendig, eller særlig brugt indenfor \gls{plc} sproget.\mefix{Måske lidt en bred påstand}\\

\noindent\textbf{Kontrolstruktur}
er placeret under must have, af den grund at det foruden denne funktion ville være et meget begrænset sprog, med begrænset funktionalitet.
Derfor vælges der at implementere \textit{if} og \textit{while}, med hendblik på senere hen at implementere \textit{for}, \textit{do-while} samt \textit{switch}.

Dette er grundet at man med \textit{if} og \textit{while} kan konstruere de andre, men ikke omvendt.

\textit{switch} er placeret under should have, og har en væsentlig betydning for hvordan programmøren strukturere sin kodning, og udformer programmer i sproget.
Hertil er det ikke nødvendigt, da programmøren kan konstruere en switch ligende situration ved hjælp \textit{if} og \textit{else} løkker. 

\textit{do-while} er placeret under could have, siden det ikke bliver brugt særlig meget i \gls{plc} programmering, og derfor vurderes som irrelevant på en hvis front.\\

\noindent\textbf{Funktioner}
er med til at opdele programmet i flere dele, dette gør det mere læsbart og isolere koden i små scoops.

Dette er med til at øge abstraktionsniveauet og giver mulighed for at genbruge kode i andre handlinger.
Funktioner er en af byggestenene for programmeringssproget og er derved kategoriseret som must have.\\

\noindent\textbf{Betingede udtryk}
Betingede udtryk er et udtryk der giver mulighed for at først have en betingelse og så en expression hvis betingelsen er sand eller en anden hvis betingelsen er falsk.\\

\noindent\textbf{Generelt} er der integreret flere funktioner som hovedsageligt er mere globale og kan bruges generelt i flere sammenhænge. En af disse funktioner er kommentarer som er essentielt for et programmeringssprog at indeholde, og derfor er funktionen placeret under Must have. Kommentarer giver mulighed for at strukturere kode, og skriv en kommentar til det, hvilket kan gøre det mere overskueligt i store såvel som små programmer.

Udover kommentarer er der implementeret flere operatorer, som gør det muligt at lave matematiske operationer, dette er nemt at implementerer og en basal funktion som skal være til stede ved \gls{plc} programmering.

Til sidst er det muligt at lave assignments og declerations som er essentielt for at kunne tildele variabler eller udtryk en værdi.

\subsection{Forskel fra C}
\label{sec:forskelfrac}
I projektet er der blevet taget udgangspunkt i C, hvor man har valgt at tage sin egen erfaring med C kombineret med andres, og taget det bedste fra sproget samt tilføjet eventuelle mangler eller ønsker.
Nogle af disse tilføjelser er blandt andet den boolske datatype, som giver et højere abstraktion, hvilket gør det  lettere for programmøren at associere det med virkelige hændelser.

Hertil giver det anledning til at programmøren ikke laver lige så mange fejl, baseret på at datatypen \textit{boolean} kun acceptere true/false, hvorimod en \textit{int} som agerer som en \textit{boolean}, men kan acceptere flere værdier.

Ligeledes er det valgt ikke at implementere pointeraritmetik af den grund, at det skaber potentielle fejlkilder, som kan være en hindring for selv den øvede programmør. Hertil er det tænkt at det skal være et effektivt programmeringssprog, hvor programmøren ikke eksplicit skal erklærer hvad han/hun vil.

\subsection{Kriterier}
Dette afsnit resultere i en række kriterier som er prioriteret efter behov, som er med til at skabe et brugbart og yderst velegnet sprog til målgruppen, uden væsentlige svagheder. Omtalte behov kan delvist udledes fra problemanalysen \mefix{indsæt ref}, såvel som \gls{moscow}-analysen.
Følgende sektioner udspecificere kriterierne individuelt og deres prioritet i en samlet tabel.\\

\noindent\textbf{Readability} er kriteriet som omhandler hvor læsbart programmet er, samt om programmøren kan se handlingen og derved forstå hvad der programmet gør.

Dette er vigtigt i den forstand, at en ny programmør hurtigt skal kunne sætte sig ind i, hvordan programmet fungere, for at undgå yderligere omkostninger. 

Readability er blevet placeret i kategorien "Vigtig" på grund af det "trade-off" som finder sted, når man vælger at øge writeability´en.
Dette trade-off sker, ved at man øger writeabilityen som gør at koden er lettere at skrive, hvilket ikke altid gør det lettere at læse, og omvendt bliver det ikke lettere at skrive hvis det skal være lettere at skrive, og dermed kan man i de fleste tilfælde ikke opnå begge dele.
\\
Dette vil sige at et for loop i sproget COBOL er mere læsbart i forhold til C\#, dette kan ses på kodeeksempel \ref{code:ekscobol}

\Cobol{Kode/Readability-cobol.cbl}{For-loop}{ekscobol}

\noindent Man ser at opbygningen af koden, ligner meget en almindelig sætning, hvilket er meget let at læse. Derimod hvis man ser på C\# kodeeksempel \ref{code:ekscsharp} kan man se at opbygningen af opbygningen af sætningen indeholder parenteser, akkolade og semikolon, hvilket gør det besværligt at læse for en person, som ikke har arbejdet med programmering før.

\CSharp{Kode/Readability-csharp.cs}{For-loop}{ekscsharp}


\noindent\textbf{Writeability} er hvordan koden skrives i et dokument, samt hvilken syntaks der benyttes. Dette er med til at sikre, at programmøren hurtigt og effektivt kan skrive koden.

Dette kan være en hurtigere repræsentation af funktionen, som gør det hurtigere at skrive det. Dette giver et trade-off i Readability, da det gør det sværer at læse.\\

\noindent\textbf{Adaptability} er muligheden for at tilpasse koden til andre enheder, hvor det i \gls{plc} verdenen, ville betyde at man ville kunne bruge programmeringssproget, på flere forskellige enheder selvom det er forskellige producenter. Adaptability er valgt at kategorisere som vigtigt, da det ville være lettere for en automatiktekniker at kunne lærer et sprog, og kunne bruge det til alle \gls{plc} enheder.

Dette giver programmøren uafhængighed i forhold til hvilken producent vil arbejde med, og giver derved flere jobmuligheder.\\

\noindent\textbf{Learnability} er hvor let programmeringssproget er at lærer, og hvor let det er at benytte det.

Herunder er Learnability hvor nemt programmøren har ved at indlærer nye funktioner, ud fra dokumentationen, da programmøren umuligt kan huske alle funktioner i et stort sprog, og derved skal kunne indlærer det på ny, ved at kigge på et dataark. \\
Learnability er placeret under mindre vigtigt, da sproget er prioriteret til automatikteknikere, som har gennemgået et grundkursus, hvilket er med til at sikre at den kommende programmør bliver sat ordenligt ind i sproget. Hermed er det valgt at nedprioritere sprogets learnability, således der kan implementeres flere funktioner, som giver en rig mulighed for udnyttelse af hele \gls{plc}´en.\\

\noindent\textbf{Orthogonality} er muligheden for at kunne kombinere forskellige dele af sproget til mere avancerede konstruktioner. Særregler gør sproget mindre ortogonalt. Hvis det er muligt at benytte alle mulige kombinationer er sproget altså ortogonalt.\\\sfix{Tjek op på forklaringen}

\noindent\textbf{Reliability} er hvordan koden håndtere fejl, og hvor pålideligt det generelt er. Dette er med til at sikre at maskiner som kører med denne kode, har en form for fejlhåndtering, som giver programmøren mulighed for at kunne bearbejde fejlen, og derved endda kunne fortsætte programmet, selvom der opstod en fejl.

Dette er en yderst vigtig parameter i løsningen, da det skal kører på en \gls{plc} hvor driftsikkerhed er en af top prioriteterne.\\


\begin{table}[H]
\centering       
\rowcolors{2}{blue!10}{white}
\begin{tabular}{l c c c c}
\toprule
\textbf{Kriterium} & \textbf{Meget vigtigt} & \textbf{Vigtigt} & \textbf{Mindre vigtigt}  \\ \midrule
Readability        &   & X &       \\ 
Writeability       & X &   &       \\ 
Adaptability       &   & X &       \\ 
Learnability       &   &   & X     \\ 
Orthogonality      &   & X &       \\ 
Reliability        & X &   &       \\ \bottomrule
\end{tabular}
\caption{Endelige kriterier som løsningen skal opfylde.}
\label{table:kriterier}
\end{table}