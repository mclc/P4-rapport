\section{Kravspecifikation}
Kravene til PLC++ tager udgangspunkt i C med en del ændringer. C bidrager til kravet om abstraktionsniveauet med dets mulighed for at benytte funktioner. Ligeledes har C datatypen \textit{struct} som kan imitere objekter i den virkelige verden.

De vigtigste krav til PLC++ vil blive gennemgået, forklaret og prioriteret i en MosCOW. Den fulde syntax specifikation kan findes i bilag \ref{bil:cfg}

\subsection{MoSCoW}
\gls{moscow}-analysen har til formål at belyse kravspecifikationens funktioner, samt opnåelse af disse.
Disse funktioner kan ved hjælp af en \gls{moscow}-analyse opstilles med prioritet, for hver individuelle funktion.
Prioriteringen for den individuelle funktion er nødvendig, i forhold til det tidsmæssige aspekt, og giver ydermere en arbejdsstruktur for implementationen af funktionen.

%
% DENNE TABEL ER LIDT FOR STOR, MEN ELLERS KAN DET IKKE STÅ PÆNT, OG MAN SER DET IKKE I RAPPORTEN.....
%
\begin{table}[H]
\centering
%\rowcolors{2}{blue!10}{white}
\begin{tabular}{l|l|l|l}
\toprule
\textbf{Must have} & \textbf{Should have} & \textbf{Could have} & \textbf{Want to have} \\ \midrule
Kontrolstruktur & Increment/Decrement & Const & Betingede udtryk   \\ 
Datatyper & Compound assignments & Unsigned datatyper  & \\ 
Structs & Information hiding &  &	   \\ 
Specielle Datatyper	&  &  &		   \\ 
Funktioner &  &  & 		   \\ 
Kommentarer &  &  & 		   \\ 
Arrays &  &  & 	   \\ 
Operatorer &  &  & 		   \\ \bottomrule
 
%if & for & do-While & Betingede udtryk   \\ \hline
%int & decrement & const & unsigned int  \\ \hline

% structs & increment & Optimizer &    \\ \hline
% Expressions & Compound assignments &  &   \\ \hline
% while & switch &  &    \\ \hline
 
% char & string &  & unsigned char  \\ \hline
% long &  &  & unsigned long  \\ \hline
% float &  &  &   \\ \hline
% double &  &  &   \\ \hline
% timer &  &  &   \\ \hline
% port &  &  &   \\ \hline
% bool &  &  &   \\ \hline
% funktioner &  &  &    \\ \hline
% array &  &  &    \\ \hline
% Kommentarer &  &  &   \\ \hline
% Operatorere &  &  &   \\ \hline

% Assignments &  &  &    \\ \hline
% Declaration  &  &  &   \\ \hline
\end{tabular}
\caption{MoSCoW-tabel}
\label{tab:moscow}
\end{table}\sfix{Hvad er specielle datatyper?}

\noindent Som en forklaring på disse funktioner beskrives de i kategorier herunder.\\

\noindent\textbf{Kontrolstruktur}
er placeret under must have da kontrolstrukturer er en central del af programmering.
Derfor vælges der at implementere \textit{if} og \textit{while}, med hendblik på senere hen at implementere \textit{for}, \textit{do-while} samt \textit{switch}.

Dette er grundet at man med \textit{if} og \textit{while} kan konstruere de andre, men ikke omvendt. Dog kan det være besværgelig og ineffektivt at konstruere en switch vha. if.

\textit{switch} er placeret under should have, og kan have en væsentlig betydning for hvordan programmøren strukturerer sin kodning og udformer programmer i sproget.
Switch er placeret under could have, da alle switch kontrolstrukturer kan konstrueres vha. if kontrolstrukturen. Dog kan det i visse tilfælde være besværeligt og direkte ineffektivt at konstruere en switch vha. if kontrolstrukturen, hvis switch kontrolstrukturen kan falde igennem til næste betingelse.

\textit{do-while} er placeret under could have, siden det ikke bliver brugt særlig meget i \gls{plc} programmering, og derfor vurderes det som værende irrelevant.\\

\noindent\textbf{Datatyper og unsigned}
er de basale typer sproget indeholder. PLC++'s typesystem er meget sammenligning med C med et par få tilføjelser, disse tilføjelser er timer, port samt bool.\\
Timer er en speciel struct der ikke kræver struct er skrevet foran denne. Timer structen er implementeret i standard biblioteket og benytter brugerdefinere compiler genererede metoder. Timers funktionalitet er at kunne starte/stoppe en timer, der giver et output når intervallet timeren er sat til er udløbet.\\
Port er en datatype, som enten kan være defineret som \textit{'I'} (Input), \textit{'Q'} (Output), \textit{'M'} (Intern memory), \textit{'AI'} (Analog input), \textit{'AQ'} (Analog output) og som indeholder et \# efterfølgende. Denne datatype kan bruges til at skifte en port til en anden på kørselstidspunktet. Dette er eksempelvis praktisk i forhold til funktioner, da man så kan tage en port som input parameter.\sfix{Reelt set er vores port datatype useless}

Strings er ikke implementeret i PLC++ og er derfor under want to have da anvendelsesområdet til en \gls{plc} er meget lille, da \gls{plc}'er typisk udenlukkende arbejder med boolske værdier. En senere udvidelse kunne dog inkludere strings for at skabe større integration med \gls{hmi}\sfix{Nogle der definerer hmi under problemanalysen?}.

%String har man valgt at sætte, som et højrankeret funktionalitetskrav i \gls{moscow}-analysen, da dette giver mulighed for at let håndtering af strenge baseret på text, tal og karaktere. \mefix{Vend tilbage, når string er implementeret, og skriv hvordan}

Til sidst er \textit{boolean} implementeret, hvilket kan læses under afsnit \ref{sec:forskelfrac}\\
Unsigned er blevet nedprioriteret og derved placeret i could have, da denne funktionalitet ikke er yderst nødvendig, eller særlig brugt indenfor \gls{plc} udvikling.\mefix{Måske lidt en bred påstand}\\

\noindent\textbf{Structs}
Structs er en måde at gruppere data således man har en type der kan indeholde flere og forskellige typer. Derudover har hver variabel i en struct et navn, som derfor hjælper for abstraktionen. Eksempelvis skal et punkt have både en x og y kordinat. En funktion vil dermed kunne tage et punkt som input parameter, i stedet for at skulle overføre de enkelte variabler. Structs bliver dermed en meget stor fordel ved behov for mange variabler.

For at øge abstraktionen yderligere kan man implementere muligheden for funktioner inde i structs. Dette giver mulighed for at stille en række hjælpemetoder til rådighed for den konkrete struct. Dermed slippes for funktioner med forskellige prefixes for at forhindre at funktionsnavnene konflikter.

En måde man kan øge abstraktions niveauet endnu mere er vha. information hiding således det er muligt at skjule konkrete implementationsdeltaljer for resten af koden. Derudover kan nedarvning og polyformeri også være godt for genbrugeligheden i kode.

Disse egenskaber definere desuden det objektorienterede paradigme, som derfor tilbyder endnu højere abstraktion end den helt simple struct der kun kan indeholde felter. Dog kaldes det objekter i det objektorienterede paradigme. Derudover er der også forskel på hukommelseshåndteringen mellem objekter og structs.

Der er blevet valgt at fokusere på det imperative paradigme og derfor implementeres ikke nedarvning og polyformeri. Nedarvning og polyformeri bruger ofte flere ressourcer og er derfor uegnet til PLC verdenen da hastigheden kan have stor indflydelse. Derudover bliver \gls{plc} projekter oftest ikke så store, dels pga. de typiske opgavers kompleksitet og dels hastigheden på PLC'en. Implementeringen af det objektorinterede paradigme kan derfor ved større projekter som OOP er mest egnet til vise sig at blive for ressourcekrævende.\sfix{Skal vi flytte denne her del til problemanalyse og referere der til i stedet?}

Information hiding kan være praktisk for \gls{plc} programmering, da det gør det muligt at stille et public api til rådighed for structs, som skjuler konkrete implementationsdeltalier. Information hiding kan desuden laves som et compiler step og bruger derfor ikke yderligere ressourcer. Information hideing bliver derfor placeret i moscow analysen under should have.

\noindent\textbf{Arrays}
er en let og overskuelig måde at opbevare et dataset, og er derfor på listen over must have. Arrays giver muligheden for at indeksere hvert felt med et tal, og giver dermed fleksibilitet og overskuelighed som kendt fra \textit{C}.

Men for at øge abstraktions niveauet og dermed gøre det mere overskueligt for programmøren ville en implementation af denne funktion være ideel.\\

\noindent\textbf{Const}
giver mulighed for at bibeholde dataene i den pågældende variablel, og derved giver den en form for skrivebeskyttelse, således at man ikke kan overskrive denne.

Funktionen er placeret under could have, da den ikke er essentiel for at programmet kan køre, eller gør det lettere for programmøren. 
Dog kan den i flere tilfælde være rar at benytte, og tilføjes derfor som en mulig implementation.\\

\noindent\textbf{Funktioner}
er med til at opdele programmet i flere dele, dette gør det mere læsbart og isolerer koden i små scoops.

Dette er med til at øge abstraktionsniveauet og giver mulighed for at genbruge kode i andre handlinger.
Funktioner er en af byggestenene for programmeringssproget og er derved kategoriseret som must have.\\

\noindent\textbf{Betingede udtryk}
Betingede udtryk er et udtryk der giver mulighed for at først have en betingelse og så en expression hvis betingelsen er sand eller en anden hvis betingelsen er falsk.\\

\noindent\textbf{Generelt} er der integreret flere funktioner som hovedsageligt er mere globale og kan bruges generelt i flere sammenhænge. En af disse funktioner er kommentarer som er essentielt for et programmeringssprog at indeholde, og derfor er funktionen placeret under Must have. Kommentarer giver mulighed for at strukturere kode, og skriv en kommentar til det, hvilket kan gøre det mere overskueligt i store såvel som små programmer.

Udover kommentarer er der implementeret flere operatorer, som gør det muligt at lave matematiske operationer, dette er nemt at implementere og en basal funktion som skal være til stede ved \gls{plc} programmering.

Til sidst skal det være muligt at lave assignments og declarations som er essentielt for at kunne tildele variabler eller udtryk en værdi.

\subsection{Forskel fra C}
\label{sec:forskelfrac}
I projektet er der blevet taget udgangspunkt i C, hvor man har valgt at tage sin egen erfaring med C kombineret med andres, og tage det bedste fra sproget samt tilføje eventuelle mangler eller ønsker.
Nogle af disse tilføjelser er blandt andet den boolske datatype, som giver et højere abstraktion, hvilket gør det  lettere for programmøren at associere det med virkelige hændelser.

Hertil giver det anledning til at programmøren ikke laver lige så mange fejl, baseret på at datatypen \textit{boolean} kun accepterer true/false, hvorimod en \textit{int} som agerer som en \textit{boolean} i C kan acceptere flere værdier.

Ligeledes er det valgt ikke at implementere pointeraritmetik af den grund, at det skaber potentielle fejlkilder, som kan være en hindring for selv den øvede programmør. Hertil er det tænkt at det skal være et effektivt programmeringssprog, hvor programmøren ikke eksplicit skal erklære hvad han/hun vil.\sfix{Så er vi vel ovre i det logiske paradigme}

\subsection{Kriterier}
Dette afsnit resulterer i en række kriterier som er prioriteret efter behov, som er med til at skabe et brugbart og yderst velegnet sprog til målgruppen uden væsentlige svagheder. Omtalte behov kan delvist udledes fra problemanalysen (Afsnit \ref{sec:problemanalyse}), såvel som \gls{moscow}-analysen.
Følgende sektioner udspecificerer kriterierne individuelt og deres prioritet i en samlet tabel.\\

\noindent\textbf{Readability} er kriteriet som omhandler hvor læsbart programmet er, samt om programmøren kan se handlingen og derved forstå hvad der programmet gør.

Dette er vigtigt for at en ny programmør hurtigt kan sætte sig ind i hvordan programmet fungerer. Dermed spares penge, da programmøren skal bruge mindre tid på at finde ud af hvad koden gør. 

Readability er blevet placeret i kategorien "Vigtig" på grund af det "trade-off" som finder sted, når man vælger at øge writeability´en.
Dette trade-off sker, ved at man øger writeabilityen som gør at koden er lettere at skrive, hvilket ikke altid gør det lettere at læse, og omvendt bliver det ikke lettere at skrive hvis det skal være lettere at skrive, og dermed kan man i de fleste tilfælde ikke opnå begge dele.
\\
Dette vil sige at et for loop i sproget COBOL er mere læsbart i forhold til C\#, dette kan ses på kodeeksempel \ref{code:ekscobol}

\Cobol{Kode/Readability-cobol.cbl}{For-loop}{ekscobol}

\noindent Man ser at opbygningen af koden, ligner meget en almindelig sætning, hvilket er meget let at læse. Derimod hvis man ser på C\# kodeeksempel \ref{code:ekscsharp} kan man se at opbygningen af opbygningen af sætningen indeholder parenteser, akkolade og semikolon, hvilket gør det besværligt at læse for programmører.

\CSharp{Kode/Readability-csharp.cs}{For-loop}{ekscsharp}


\noindent\textbf{Writeability} er et kriterie for hvor let det er at skrive koden. Dermed har writability meget af gøre med hvilken syntaks der benyttes. Dette er med til at sikre, at programmøren hurtigt og effektivt kan skrive koden.

Eksempelvis indeholder nogle sprog begin og end blokke, hvor andre bruger et enkelt tegn til at repræsentere det samme, herunder typisk et scope. Dermed er det meget hurtigere at skrive kode i sproget der kun kræver et tegn hver gang programmøren ønsker et nyt scope.

Writability giver dog typisk et trade-off i forhold til Readability, som forklaret under Readability.\\

\noindent\textbf{Adaptability} er muligheden for at tilpasse koden til andre enheder, hvor det i \gls{plc} verdenen, ville betyde at man ville kunne bruge programmeringssproget, på flere forskellige enheder selvom det er forskellige producenter. Adaptability er valgt at kategorisere som vigtigt, da det ville være lettere for en automatiktekniker at kunne lærer et sprog, og kunne bruge det til alle \gls{plc} enheder.

Dette giver programmøren uafhængighed i forhold til hvilken producent programmøren vil arbejde med.\\

\noindent\textbf{Learnability} er hvor let programmeringssproget er at lære, og hvor let det er at benytte det.

Herunder er Learnability hvor nemt programmøren har ved at indlærer nye funktioner, ud fra dokumentationen, da programmøren umuligt kan huske alle funktioner i et stort sprog, og derved skal kunne indlære det på ny, ved at kigge på et dataark. \\
Learnability er placeret under mindre vigtigt, da sproget er prioriteret til automatikteknikere, som har gennemgået et grundkursus, hvilket er med til at sikre at den kommende programmør bliver sat ordenligt ind i sproget. Hermed er det valgt at nedprioritere sprogets learnability, således der kan implementeres flere funktioner, som giver en rig mulighed for udnyttelse af hele \gls{plc}´en.\\\sfix{Jeg ville prioritere anderledes - det er netop vigtigt så vi kan få anvendelsen af PLC++ højere op}

\noindent\textbf{Orthogonality} er muligheden for at kunne kombinere forskellige dele af sproget til mere avancerede konstruktioner. Særregler gør sproget mindre ortogonalt. Hvis det er muligt at benytte alle mulige kombinationer af sprogets dele er sproget altså fuldstændigt ortogonalt. Dermed kan orthogonality have indflydelse på både writability idet det bliver lettere at lave avancerede konstruktioner, readability da konstruktionerne kan blive meget komplekse og dermed mindre læsbare. Da skrivbarhed også er meget vigtigt er orthogonality ligeledes blevet lagt under vigtigt sammen med readability. Orthogonality er dog ikke målet i sig selv, og det er derfor vigtigere med højere readability.\\\sfix{Tjek op på forklaringen - prioritet?}

\noindent\textbf{Reliability} er hvordan koden håndterer fejl, og hvor pålideligt koden der kan skrives med programmeringssproget er. Dette er med til at sikre at maskiner som kører med denne kode, har en form for fejlhåndtering, som giver programmøren mulighed for at kunne bearbejde fejlen, og derved endda kunne fortsætte programmet, selvom der opstod en fejl.

Dette er en vigtig parameter i løsningen, da det skal kører på en \gls{plc} hvor driftsikkerhed er en af top prioriteterne. Dog er fejlhåndtering vha. exceptions ineffektivt og der afgrænses i første omgang derfor for fra det.\\\sfix{Argument igen for imperativt - men også argument for exception handling}


\begin{table}[H]
\centering
\rowcolors{2}{blue!10}{white}
\begin{tabular}{l c c c c}
\toprule
\textbf{Kriterium} & \textbf{Meget vigtigt} & \textbf{Vigtigt} & \textbf{Mindre vigtigt}  \\ \midrule
Readability        &   & X &       \\ 
Writeability       & X &   &       \\ 
Adaptability       &   & X &       \\ 
Learnability       &   &   & X     \\ 
Orthogonality      &   & X &       \\ 
Reliability        & X &   &       \\ \bottomrule
\end{tabular}
\caption{Endelige kriterier som løsningen skal opfylde.}
\label{table:kriterier}
\end{table}