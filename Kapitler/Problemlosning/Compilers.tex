\section{Compilere}
Compilere er grundstenen i alt programmering, og store dele af datalogien, som vi kender den i dag. De tidlige udgaver af programmer og styresystemer blev skrevet i ren maskine - en disciplin som de færreste mennesker er i stand til at udføre. Derfor blev konceptet med høj-niveau sprog opfundet. Det vil sige at man kan skrive et stykke software, med bogstaver og ord som er væsentligt mere læsbar for mennesket. Herefter transformerer et andet stykke software dette tekst om til maskinkode - dette er en compiler.


%\figur{Figurer/Compiler-opbygning.png}{Opbygning af en compiler}{Compiler-opbygning}{1}

\tikzfigure{Figurer/TikZ/CompilerOpbygning.tex}{Opbygningen af en compiler}{Compiler-opbygning}


\noindent Som nævnt har en compiler den funktion at omdanne et højniveau-sprog til maskinkode. Kigger man på figur \ref{fig:Compiler-opbygning} ses det dog at der flere andre ting undervejs.

\subsection{Syntax Analysis}
Den første del af en compiler, syntaksanalysen, har til ansvar at læse kildekoden som rent tekst og omdanne det til et abstrakt syntakstræ, som efterfølgende kan bruges i det videre arbejde mod maskinkode. Denne analyse er typisk opdelt i to underdele: Scanneren og parseren. 

\subsubsection{Scanner}
Scanneren sørger for at opdele kildekoden i såkaldte "tokens"\mbox{}, som er de mindste dele af et sprog. For at illustrere dette, ses et lille kodestykke i sproget Mini Triangle i kodeeksempel \ref{code:minitriangleforscanner}.

\MT{Kode/MiniTriangleForScanner.mt}{Lille program i Mini Triangle}{minitriangleforscanner}

\noindent Hvis der tager udgangspunkt i linje 1 fra kode \ref{code:minitriangleforscanner} ses det at der er nogle forskellige "ord"\mbox{}. Det er disse ord der skal forstås som tokens. Disse er inddelt i forskellige kategorier - typisk én kategori til hvert keyword\fn{Keyword}{Et bestemt ord i et programmeringssprog, som er reserveret til et bestemt formål}, for eksempel \textit{let} og \textit{var}, samt identifiers. Opdelingen i tokens ses i tabel \ref{tab:tokensMT}

\begin{table}[H]
\centering
    \begin{tabular}{|c|c|c|c|c|}
    \hline
    \textbf{let} & \textbf{var} & \textbf{identifier} & \textbf{colon} & \textbf{identifier} \\ \hline
    let          & var          & y                   & :              & Integer             \\ \hline
    \end{tabular}
\caption{\textit{Opdeling af tokens}}
\label{tab:tokensMT}
\end{table}

\noindent Da input'et nu er scannet og opdelt i tokens, er det muligt at bygge et abstrakt syntakstræ.

\subsubsection{Parser}
Som nævnt er opgaven nu at få bygget et abstrakt syntakstræ. Fordelene ved at arbejde med træer generelt, er muligheden for at gennemløbe det på flere forskellige måder - eksempelvis ved hjælp af Visitor-mønstret, som forklares nærmere i afsnit \ref{sec:visitor}

\figur{Figurer/MTAST.png}{Abstrakt syntakstræ baseret på kodeeksempel \ref{code:minitriangleforscanner}}{MTAST}{1.0}

\noindent På figur \ref{fig:MTAST} ses et sådant træ for koden vist i eksempel \ref{code:minitriangleforscanner}. For at forstå hvordan træet er bygget op, er det dog nødvendigt også at kende til CFG\fn{CFG}{Context-Free Grammar / Kontekstfri Grammatik}. Denne forklares i dybden i afsnit x.x\mfix{Mangler ref}, men den konkrete CFG for Mini Triangle kan ses i bilag \ref{bil:minitriangle}. Eksempelvis ses det øverste i den øverste del af træet at \textit{single-Command} består af "\textit{let} Declaration \textit{in} single-Command"\mbox{}, hvilket passer med grammatikken.

\subsection{Contextual Analysis}
Hvis der tages et kig tilbage på figur \ref{fig:Compiler-opbygning} ses det at det abstrakte syntakstræ nu skal "dekoreres"\mbox{}. Det vil altså sige at hver enkel token/knude skal have tilknyttet mere information - dette inkluderer blandt andet oplysninger om typer.\wip{}

\subsection{Code Generation}