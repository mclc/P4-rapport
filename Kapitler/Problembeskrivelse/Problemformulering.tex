\section{Problemformulering}
Problemanalysen belyste indledningsvist (se afsnit \ref{subsec:pa-hardware}) en række hardwaremæssige fordele og ulemper. En af fordelene var især \gls{plc}'ens mekaniske konstruktion, som viste sig at være designet til hårde arbejdsmiljøer, hvor rystelser, støj og temperatursvigninger var . Imidlertid blev det belyst, at \gls{plc}'en har kompatibilitetsproblemer, både på det hardware- såvel som det softwaremæssige plan. Programmørene har dermed ikke mulighed for at udvide produktionsanlæggets med udvidelsesmoduler, som ikke er produceret af tilsvarende firma.

De opsatte hardwaremæssige problemstillinger, er dog ikke noget som kan løses med en hensigtsmæssig softwareløsning, og bliver dermed afgrænset. 

IEC-1131-3 standarden, som blev udarbejdet for at skabe en generel kode-konsensus for \gls{plc}'er, viste problemanalysen at producenterne, Omron og Siemens har modificeret \gls{il}-instrukserne, hvilket naturligvis ledsager til softwaremæssige kompatibilitetsproblemer. Dette problem vil komme til udtryk, såfremt at PLC++ oversættes til \gls{il}-instrukser. Imidlertid ville problemet kunne løses ved at tilpasse \gls{il}-instrukserne baseret på hvilken model, der skal køre det pågældende program.

Gennemgangen af \gls{plc}'ens software viste sig ligeledes at have en række fordele og ulemper. \gls{plc}'er er opbygget i det logiske programmeringsparadigme, hvor de grafiske sprog såsom \gls{lad} og \gls{fbd}, gør det nemt for programmøren at opsætte et fungerende program. Det kræver ikke den store programmeringserfaring, udover kendskab til variabler og håndtering af hukommelse, for at få et simpelt program op at køre. Det viste sig dog også (se afsnit refxx) at mellemstore programmer, bestående af ét transportbånd og én drejearm, kan have en negativ indflydelse på læsbarheden af koden. Læsbarheden blev både forringet i det grafiske (\gls{lad}) såvel som det tekstrepræsenteret sprog (\gls{il}). 

\noindent Det logiske programmeringsparadigme egner sig især til mindre anlæg, og dermed mindre programmeringsopgaver.







 I takt med at anlægget bliver mere omstændeligt, ville det sandsynligvis falde den erfarende programmør naturligt at skifte til \gls{oop}-programmeringsparadigmet, hvorved forøget abstraktionsniveau ville ledsage til forsøget udviklingsomkostnigner, begrænset test-tid, programmets robusthed samt et forøget overblik. 

Det kan dog anses for værende en tidskrævende proces - især for industriteknikere, som ikke besidder yderligere programmeringserfaring, foruden det obligatoriske \gls{plc}-kursus - at tilpasse sig \gls{oop}-programmeringsparadigmet\cite{dislikes_oop}. 
Kan der i stedet konstruereres en programmeringsløsning, som tager det bedste fra begge programmeringsparadigmer, uden at gå på kompromis med bestandige funktionaliteter, ville der muligvis være flere industriteknikere, som ville migrere over til et mere moderne programmeringssprog. Med denne afslutning, er følgende problemformulering blevet opstillet: \\

\noindent\textit{Hvordan kan der konstruereres et hensigtsmæssigt programmeringssprog, som gør det nemmere at bevare overblikket ved større \gls{plc}-programmeringsopgaver, men stadig ikke bliver så omstændigt, at industriteknikere ikke vil skifte?}


%\gls{lad} viste sig at være det mest udbredte programmeringssprog, hvilket sandsynligvis skyldes producenternes implementation af Drag \& Drop i deres tilhørende \gls{ide}. Det giver programmøren - uden større programmeringsmæssige erfaring - et let tilgængeligt og indlæringsnemt programmeringsværktøj. Imidlertid viste det sig at der var en flere ulemper forbundet med \gls{lad}-programmeringssproget. 

%Race-conditions er et problem, som ofte forekommer i \gls{plc}-verdenen, og ligeledes kan aritmetiske operationer være besværlig at udtrykke - uden at det går ud over læsbarheden. Ydermere understøttes iterative kontrolstrukturer ikke, hvor \gls{lad} i stedet anvender counter-funktionsblokke. Det ledsager til situationer, hvor programmøren er nødsaget til implementere funktioner, som består af identiske kontrolstrukturer, med den eneste forskel, at counterens preset-værdi varierer. \\
