\section{Problemformulering}
Problemanalysen belyste indledningsvist (\ref{subsec:pa-hardware}) en række hardwaremæssige fordele og ulemper. Fordelene var især \gls{plc}'ens mekaniske konstruktion, som viste sig at være designet til hårde arbejdsmiljøer, hvorved \gls{plc}'en viste sig at være modstanddygtig overfor rystelser, støj og temperatursvigninger. Imidlertid blev det belyst, at \gls{plc}'en har kompatibilitetsproblemer, både på det hardware- og softwaremæssige plan. Programmørene har dermed ikke mulighed for at udvide produktionsanlæggets med udvidelsesmoduler, som ikke er produceret af tilsvarende firma.

Trods IEC-1131-3 standarden, har producenterne valgt at implementerer egne operationer til deres programmeringssprog, hvilket kan ledsage til kompatibilitetsproblemer på tværs af \gls{plc}-producenterne. De statuerede hardwaremæssige problemstillinger, er dog ikke noget som kan løses med en hensigtsmæssig softwareløsning, og bliver dermed afgrænset. 
Gennemgangen af \gls{plc}'ens software viste sig ligeledes at have en række fordele og ulemper. \gls{plc} er opbygget i et funktionelt programmeringsparadigme; hvorved programmøren var frit stillet til at benytte dét programmeringssprog, som føltes bedst egnet til den konkrete arbejdsopgave. \gls{lad} viste sig at være det mest udbredte programmeringssprog, hvilket sandsynligvis skyldes producenternes implementation af Drag \& Drop i deres tilhørende \gls{ide}. Det giver programmøren - uden større programmeringsmæssige erfaring - et let tilgængeligt og indlæringsnemt programmeringsværktøj. Imidlertid viste det sig at der var en flere ulemper forbundet med \gls{lad}-programmeringssproget. Race-conditions er et problem, som ofte forekommer i \gls{plc}-verdenen, og ligeledes kan aritmetiske operationer være besværlig at udtrykke - uden at det går ud over læsbarheden. Ydermere understøttes iterative kontrolstrukturer ikke, hvor \gls{lad} i stedet anvender counter-funktionsblokke. Det ledsager til situationer, hvor programmøren er nødtaget til implementerer funktioner, som består af identiske kontrolstrukturer, med den eneste forskel, at counterens preset-værdi varierer. \\

\noindent Det funktionelle programmeringsparadigme egner sig især til mindre anlæg, og dermed mindre programmeringsopgaver. I takt med at anlægget bliver mere omstændeligt, ville det sandsynligvis falde den erfarende programmør naturligt at skifte til \gls{oop}-programmeringsparadigmet, hvorved forøget abstraktionsniveau ville ledsage til forsøget udviklingsomkostnigner, begrænset test-tid, programmets robusthed samt et forøget overblik. 

Det kan dog anses for værende en tidskrævende proces - især for industriteknikere, som ikke besidder yderligere programmeringserfaring, foruden det obligatoriske \gls{plc}-kursus - at tilpasse sig \gls{oop}-programmeringsparadigmet\cite{dislikes_oop}. 
Kan der i stedet konstruereres en programmeringsløsning, som tager det bedste fra begge programmeringsparadigmer, uden at gå på kompromis med bestandige funktionaliteter, ville der muligvis være flere industriteknikere, som ville migrere over til et mere moderne programmeringssprog. Med denne afslutning, er følgende problemformulering blevet opstillet: \\

\noindent\textit{Hvordan kan der konstruereres et hensigtsmæssigt programmeringssprog, som gør det nemmere at bevare overblikket ved større \gls{plc}-programmeringsopgaver, men stadig ikke bliver så omstændeligt, at industriteknikere ikke vil skifte?}